[{"title":"十分钟学会WebSocket","label":["HTML5","JAVASCRIPT"],"time":"2024-18-03 00:43:51","uptime":"2024-18-03 00:43:51","creator":"风中追风","type":"tech","abstract":"WebSocket是一种在客户端和服务器之间实现双向通信的网络协议1。它通过在单个TCP连接上提供全双工通信功能，使得服务器可以主动向客户端推送数据，而不需要客户端发起请求。","logo":"https://img0.baidu.com/it/u=248646428,2814622221&fm=253&fmt=auto&app=138&f=PNG?w=500&h=500","content":"<h2 style=\"text-align: start;\">WebSocket与HTTP的区别</h2><p style=\"text-align: start;\">与传统的HTTP协议相比，WebSocket具有以下几个显著的区别：<span style=\"color: rgb(89, 89, 89); background-color: rgb(255, 255, 255); font-size: 15px;\"><br></span></p><p style=\"text-align: start;\"><br></p><li><strong>双向通信</strong>：WebSocket支持客户端和服务器之间的实时双向通信，而HTTP协议是单向请求-响应模式。</li><li><strong>低延迟</strong>：由于WebSocket使用长连接，避免了HTTP的连接建立和断开过程，可以降低通信延迟。</li><li><strong>更少的数据传输</strong>：WebSocket头部信息相对较小，减少了数据传输的开销。</li><li><strong>跨域支持</strong>：WebSocket可以轻松跨域，而HTTP需要通过CORS等机制来实现。<br></li><h2 style=\"text-align: start;\">WebSocket的工作原理<br></h2><p><br></p><p>WebSocket的握手过程和HTTP有所不同。客户端通过发送特定的HTTP请求进行握手，服务器收到请求后进行验证，如果验证通过，则会建立WebSocket连接。</p><p>建立连接后，客户端和服务器之间可以通过WebSocket发送和接收消息，可以使用文本、二进制数据等进行通信。<br></p><h2 style=\"text-align: start;\">WebSocket的应用场景<br></h2><p><br></p><p>WebSocket的实时双向通信特性使得它在许多应用场景中发挥重要作用，例如：</p><ul><li><strong>即时聊天</strong>：WebSocket可以实现实时的聊天功能，用户可以发送和接收消息，实现快速、低延迟的聊天体验。</li><li><strong>实时数据更新</strong>：对于需要实时更新数据的应用，如股票行情、实时监控等，WebSocket可以将数据实时推送给客户端，确保数据的及时更新。</li><li><strong>在线游戏</strong>：在线游戏需要实时的双向通信，WebSocket可以提供稳定的通信通道，支持实时交互和多人游戏。<br></li></ul><h2 style=\"text-align: start;\">WebSocket的使用</h2><pre style=\"text-align: start;\"><code class=\"language-hljs language-javascript code-block-extension-codeshownum\">var Socket = new WebSocket(\"url, [protocol]\");\n\n</code></pre><p style=\"text-align: start;\">以上代码中的第一个参数<span style=\"color: rgb(38, 198, 218); background-color: rgba(77, 208, 225, 0.08);\"><code>url</code></span>, 指定连接的 URL。第二个参数<span style=\"color: rgb(38, 198, 218); background-color: rgba(77, 208, 225, 0.08);\"><code>protocol</code></span>是可选的，指定了可接受的子协议。<br></p><h4 style=\"text-align: start;\">WebSocket 属性<br></h4><p style=\"text-align: start;\">以下是 WebSocket 对象的属性。<br></p><table style=\"width: auto;\"><tbody><tr><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">属性</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">描述</th></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Socket.readyState</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">只读属性readyState表示连接状态，可以是以下值：0-表示连接尚未建立。1-表示连接已建立，可以进行通信。2-表示连接正在进行关闭。3-表示连接已经关闭或者连接不能打开。</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Socket.bufferedAmount</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">只读属性bufferedAmount已被send()放入正在队列中等待传输，但是还没有发出的UTF-8文本字节数。</td></tr></tbody></table><ul><li>0-表示连接尚未建立。</li><li>1-表示连接已建立，可以进行通信。</li><li>2-表示连接正在进行关闭。</li><li>3-表示连接已经关闭或者连接不能打开。<br></li></ul><h4 style=\"text-align: start;\">WebSocket 事件<br></h4><p style=\"text-align: start;\">以下是 WebSocket 对象的相关方法。</p><table style=\"width: auto; text-align: start;\"><tbody><tr><th colspan=\"1\" rowspan=\"1\" width=\"auto\">方法</th><th colspan=\"1\" rowspan=\"1\" width=\"auto\">描述</th></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">Socket.send()</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">使用连接发送数据</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">Socket.close()</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">关闭连接</td></tr></tbody></table><h2 style=\"text-align: start;\"><br></h2>","id":37740271083514,"lookNum":1247},{"title":"2024年令人眼前一亮的Web框架","label":["JAVASCRIPT","NEXTJS","NUSTJS","ANGULAR"],"time":"2024-03-18 03:22:04","uptime":"2024-05-05 01:43:47","creator":"风中追风","type":"tech","abstract":"2024年正向我们走来，我们怀着满腔热情为新的一年制定计划，探索未来一年可以学习或实现的目标。此时此刻，正是探寻来年值得学习的框架、理解其功能和特色的最佳时刻。我们以2023年JS 新星名单为指引，力求保持客观公正的态度。对于每一个特色框架，我们都将突出其最大的优势，使您能够全面理解它们的优点，从而选择适合自己的框架进行尝试！ ","logo":"https://pic.vjshi.com/2021-09-16/816586c10c974033982559cc1efbf52c/00003.jpg?x-oss-process=style/watermark","content":"<p><br></p><p>为谁而设：</p><ul><li>你希望减少JavaScript的编写量</li><li>你希望代码更简单，以超媒体为中心</li></ul><p>HTMX在2023年迅速走红，过去一年间在GitHub上赢得了大量星标。HTMX并非普通的JS框架。如果你使用HTMX，你将大部分时间都花在超媒体的世界中，以与我们通常对现代Web开发的JS密集型视角完全不同的视角看待Web开发。<strong>HTMX利用HATEOAS（Hypermedia作为应用程序状态的引擎）的概念，使开发人员能够直接从HTML访问浏览器功能，而不是使用Javascript。</strong></p><p>此外，它还证明了通过发布令人惊叹的表情符号并以口碑作为主要营销手段，你可以获得人气和认可。不仅如此，你还可能成为HTMX的CEO！它吸引了许多开发人员尝试这种构建网站的方法，并重新思考他们当前的实践。所有这些都使2024年对于这个库的未来发展充满了激动人心的可能性。</p><h2>Wasp - 全栈，开箱即用🚀</h2><p>为谁而设：</p><ul><li>你希望快速构建全栈应用</li><li>你希望在一个出色的一体化解决方案中继续使用React和Node.js，而无需手动挑选堆栈的每一部分</li><li>你希望获得一个为React和Node.js预配置的免费SaaS模板—— <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwasp-lang%2Fopen-saas\" target=\"_blank\">Open SaaS</a></li></ul><p>对于希望简单轻松地全面控制其堆栈的工具的用户，无需再寻找！<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwasp-lang%2Fwasp\" target=\"_blank\">Wasp</a>是一个有主见的全栈框架，利用其编译器以快速简便的方式为你的应用创建数据库、后端和前端。它使用React、Node.js和Prisma，这些都是全栈Web开发人员正在使用的一些最著名的工具。</p><p>Wasp的核心是main.wasp文件，它作为你大部分需求的一站式服务。在其中，你可以定义：</p><ul><li>全栈身份验证</li><li>数据库架构</li><li>异步作业，无需额外的基础设施</li><li>简单且灵活的部署</li><li>全栈类型安全</li><li>发送电子邮件（Sendgrid、MailGun、SMTP服务器等）</li><li>等等……</li></ul><p>最酷的事情是？经过编译器步骤后，你的Wasp应用程序的输出是一个标准的React + Vite前端、Node.js后端和PostgreSQL数据库。从那里，你可以使用单个命令轻松将一切部署到Fly.io等平台。</p><p>尽管有些人可能会认为Wasp的有主见立场是负面的，但它却是Wasp众多全栈功能的驱动力。使用Wasp，单个开发人员或小型团队启动全栈项目变得更加容易，尤其是如果你使用预制的模板或OpenSaaS作为你的SaaS起点。由于项目的核心是定义明确的，因此开始一个项目并可能在几天内创建自己的全栈SaaS变得非常容易！</p><p><strong>此外，还有一点很酷的是，大多数Web开发人员对大多数现有技术的预先存在的知识仍然在这里适用，因为Wasp使用的技术已经成熟。</strong></p><h2>Solid.js - 一流的reactivity库 ↔️</h2><p>适合人群：</p><ul><li>如果你希望代码具有高响应性</li><li>现有的React开发人员，希望尝试一种对他们来说学习曲线较低的高性能工具</li></ul><p>Solid.js是一个性能很高的Web框架，与React有一些相似之处。例如，两者都使用JSX，采用基于函数的组件方法，但Solid.js不使用虚拟DOM，而是将你的代码转换为纯JavaScript。然而，Solid.js因其利用信号、备忘录和效果实现细粒度响应性的方法而更加出名。信号是Solid.js中最简单、最知名的基本元素。它们包含值及其获取和设置函数，使框架能够观察并在DOM中的确切位置按需更新更改，这与React重新渲染整个组件的方式不同。</p><p>Solid.js不仅使用JSX，还对其进行了增强。它提供了一些很酷的新功能，例如Show组件，它可以启用JSX元素的条件渲染，以及For组件，它使在JSX中更轻松地遍历集合变得更容易。另一个重要的是，它还有一个名为Solid Start的元框架（目前处于测试版），它使用户能够根据自己的喜好，使用基于文件的路由、操作、API路由和中间件等功能，以不同的方式渲染应用程序。</p><h2>Astro - 静态网站之王👑</h2><p>适合人群：</p><ul><li>如果您需要一款优秀的博客、CMS重型网站工具</li><li>需要一个能够集成其他库和框架的框架</li></ul><p>如果您在2023年构建了一个内容驱动的网站，那么很有可能您选择了Astro作为首选框架来实现这一目标！Astro是另一个使用不同架构概念来脱颖而出的框架。对于Astro来说，这是岛屿架构。在Astro的上下文中，岛屿是页面上的任何交互式UI组件，与静态内容的大海形成鲜明对比。由于这些岛屿彼此独立运行，因此页面可以有任意数量的岛屿，但它们也可以共享状态并相互通信，这非常有用。</p><p><strong>关于Astro的另一个有趣的事情是，他们的方法使用户能够使用不同的前端框架，如React、Vue、Solid来构建他们的网站。因此，开发人员可以轻松地在其当前知识的基础上构建网站，并利用可以集成到Astro网站中的现有组件。</strong></p><h2>Svelte - 简单而有效🎯</h2><p>适合人群：</p><ul><li>您希望学习一个简单易上手的框架</li><li>追求简洁且代码执行速度快的开发体验</li></ul><p><strong>Svelte是另一个尝试通过尽可能直接和初学者友好的方式来简化和加速Web开发的框架。它是一个很容易学习的框架，因为要使一个属性具有响应性，您只需声明它并在HTML模板中使用它。</strong> 每当在JavaScript中程序化地更新值时（例如，通过触发onClick事件按钮），它将在UI上反映出来，反之亦然。</p><p>Svelte的下一步将是引入runes。runes将是Svelte处理响应性的方式，使处理大型应用程序变得更加容易。类似于Solid.js的信号，符文通过使用类似函数的语句提供了一种直接访问应用程序响应性状态的方式。与Svelte当前的工作方式相比，它们将允许用户精确定义整个脚本中哪些部分是响应性的，从而使组件更加高效。类似于Solid和Solid Start，Svelte也有其自己的框架，称为SvelteKit。SvelteKit为用户提供了一种快速启动其由Vite驱动的Svelte应用程序的方式。它提供了路由器、构建优化、不同的渲染和预渲染方式、图像优化等功能。</p><h2>Qwik - 非常快🚤</h2><p>适合人群：</p><ul><li>如果您想要一个高性能的Web应用</li><li>现有的React开发人员，希望尝试一种高性能且学习曲线平缓的框架</li></ul><p>最后一个但同样重要的框架是Qwik。<strong>Qwik是另一个利用JSX和函数组件的框架，类似于Solid.js，为基于React的开发人员提供了一个熟悉的环境，以便尽快上手。正如其名字所表达的，Qwik的主要目标是实现您应用程序的最高性能和最快执行速度。</strong></p><p>Qwik通过利用可恢复性（resumability）的概念来实现其速度。简而言之，可恢复性基于在服务器上暂停执行并在客户端上恢复执行而无需重新播放和下载全部应用程序逻辑的想法。这是通过延迟JavaScript代码的执行和下载来实现的，除非有必要处理用户交互，这是一件非常棒的事情。它使整体速度提高，并将带宽降低到绝对最小值，从而实现近乎瞬间的加载。</p><h2>结论</h2><p>在我们所提及的所有框架和库中，最大的共同点是它们的熟悉度。每个框架和库都试图以构建在当前知识基础上的方式吸引潜在的新开发者，而不是做一些全新的事情，这是一个非常棒的理念。</p><p>当然，还有许多我们未在整篇文章中提及但值得一提的库和框架。例如，Angular 除了新的标志和文档外，还包括信号和新的控制流。还有 Remix，它增加了对 Vite、React Server Components 和新的 Remix SPA 模式的支持。最后，我们不能忘记 Next.js，它在过去几年中已成为 React 开发者的默认选择，为新的 React 功能铺平了道路。</p>","id":95379130157204,"lookNum":1520},{"title":"2024 Vue 生态工具推荐","label":["VUE","UNIAPP","HTML5","CSS"],"time":"2024-03-18 03:24:10","uptime":"2024-04-14 13:40:14","creator":"风中追风","type":"tech","abstract":"在没有任何遗留限制的情况下从零启动一个项目可能会令人鸡冻，但也会令人头大。不受限制地自由构建 App 可能会导致浪费大量时间研究和评估工具，最终会分散实际工作的注意力。即使做出了最好的选择，也总会重新考虑备胎方案，这就是“选择的悖论”。","logo":"https://static.open-open.com/lib/uploadImg/20161012/20161012105523_94.png","content":"<p><br></p><p>本期共享的是 —— Vue 生态系统中的所有行业标准工具。</p><h2>包管理器</h2><p>处理外部包的人气工具有 3 种：</p><ul><li><code>npm</code></li><li><code>yarn</code></li><li><code>pnpm</code></li></ul><p><code>npm</code> 又老又慢。<code>yarn</code> 速度更快，是一个可靠的选择。但总体而言，<code>pnpm</code> 天下第一，它速度极快且节省空间。<code>pnpm</code> 在许多地方使用每段代码，而不需要额外的副本。此外，<code>pnpm</code> 本身支持具有最少配置的 monorepo 设置。</p><p>个人建议：包管理器优先选择 <code>pnpm</code></p><h2>构建工具</h2><p>在这里推荐 Vite 应该不足为奇。Vite 使用原生 ES 模块，实现快如闪电的服务器启动。Vite 具有内置的热模块替换支持，而且还通过 Rollup 优化生产构建，确保既小又快的加载打包。此外，与其他备胎方案相比，Vite 配置要容易得多。最后，Vite 因为与框架无关而获得加分。</p><p>个人推荐：构建工具优先选择 <code>Vite</code></p><h2>Vue 版本</h2><p>Vue 2 文档在搜索引擎和 Stackoverflow 中的排名仍然高举不下，如果我们必须在版本之间进行选择，这可能会令人头大。但粉丝请记住，Vue 2 不再开源维护，Vue 3 现在是长期支持的版本。Vue 3 具有先前版本的所有优点，但具有利用组合式 API 的不同语法。</p><p>个人建议：Vue 版本优先选择 Vue 3</p><h2>SFC（单文件组件）</h2><p>将组件的所有构建块保留在同一个位置是 Vue 的一大特色，SFC = 模板 + 样式 + 脚本。如果您认为某个组件变得又臭又长，那么最好将其拆分为子组件。我们仍然可以为每个部分使用不同的文件，但请不要这样做。</p><p>个人建议：优先选用 SFC</p><h2>路由</h2><p>Vue 有一个官方的路由模块，它与 Vue 内核深度集成，这使构建 SPA（单页应用程序）变得轻而易举。</p><p>一些给力的功能包括嵌套和动态路由、基于模块化组件的配置、路由参数、过渡效果、与自动活动 CSS 类的链接、HTML5 <code>history</code> 模式或哈希模式，以及可自定义的滚动行为。</p><p>由于缺乏替代品，Vue Router 无法获得应有的宣传和荣誉，但它确实是一个极其强大且功能齐全的库。</p><p>个人建议：优先选用 Vue Router</p><h2>状态管理</h2><p>这可能有点令人头大，因为在 Pinia 取代 Vuex 之前，Vuex 多年来一直是官方推荐。Pinia 是从零开始编写的，与 Vue 3 的组合式 API 架构无缝集成。Pinia 现在是状态管理的官方推荐。</p><p>Pinia 的唯一真正替代方案是使用自定义组合式函数来保存我们的状态。对于迷你 App 而言，这可能是一个不错的解决方案，但由于 Pinia 遵循相同的架构，具有很小的占用空间、增强的性能和开发工具支持，因此被强烈推荐。</p><p>个人建议：优先使用 Pinia</p><h2>数据请求</h2><p>原生 <code>fetch</code> 已经获得了重要的浏览器支持，这被认为是人气爆棚的 axios 库的替代品。VueUse 还提供了带有更高级配置选项的 <code>useFetch</code> 钩子。</p><p>但我强烈推荐的是 <code>vue-query</code>。它使用声明性语法简化了数据请求，并优雅地处理一大坨重复性任务，比如加载和错误状态、分页、过滤、排序和缓存。</p><p>个人建议：数据请求优先选择 Vue Query</p><h2>组件营销</h2><p>我确信还有其他选择，但 Storybook 占据主导地位，以至于其他所有选项都不在本人的考虑范围内。真正的问题是 Storybook 是否值得大肆宣传。</p><p>就我个人而言，我确实喜欢使用它来单独开发组件。Storybook 速度更快，让我了解组件的每个依赖。此外，它可以是一种很好的文档形式。</p><p>个人建议：组件文档优先选择 Storybook</p><h2>测试</h2><p>测试问题本身就可以写成一篇文章。我将重点关注我认为对任何 App 单元测试、e2e（端到端测试）和可视化测试都至关重要的测试类型。</p><h3>单元测试</h3><p>到目前为止，所有建议均来自我的个人经验。所以 Jest 就是我在本节中应该推荐的内容。它是一款既给力又可靠的测试运行器，我对它非常满意。</p><p>但有一个工具我还没有机会测试。Vitest 是一个由 Vite 驱动的测试运行器，具有兼容 Jest 的语法，我认识的每个人都支持它。所以我必须选择它作为推荐。</p><p>个人建议：单元测试优先选择 Vitest</p><h3>端到端测试</h3><p>使用 Cypress，它不仅是人气最高的选项，而且最新版本在稳定性和消除不稳定方面投入了大量精力。除了成为对开发者最友好的工具之外，它还使其成为 e2e 测试的最佳选择。</p><p>另一种选择是 Playwright，总体上可能会更快一些，但对我来说，采用率和生态系统还不够大，不足以在我的管道中得到信任。</p><p>个人建议：端到端测试优先选择 Cypress</p><h3>可视化测试</h3><p>这个难以抉择。我目前正在使用 Applitools，并且我非常了解良好的可视化测试套件的重要性。虽然但是，多用户环境中的冲突解决是极其痛苦的，并且绝对可以改进。</p><p>我的建议肯定是拥​​有一个可视化测试套件，我保证当我的工作流程不再让我头大时，我会带着一个特定的工具回来。</p><p>个人建议：你开心就好</p><h2>UI 框架</h2><p>我甚至不记得我最后一次使用 UI 框架的愉快经历。而且可能它并不在 Vue 世界中。选择很多，但问题也很多。配置地狱、臃肿的实现、糟糕的性能和内存泄漏等等。这就是为什么我当前建议在无头组件库之上进行自定义实现。在 Vue 世界中，这意味着 shadcn-vue 构建在 radix-vue 之上。这不是一个我们可以立即安装并开始使用的库。我们需要努力使其适应我们的风格指南，对我来说，这是一件好事。</p><p>根据记录，如果您想要开箱即用的 UI 库，若干人气爆棚的选项包括但不限于：</p><ul><li>Vuetify</li><li>Element UI</li><li>Quasar Framework</li></ul><p>个人建议：UI 框架优先选择 shadcn-vue 和 radix-vue</p><h2>静态类型</h2><p>毋庸置疑，这个话题的争议性比超乎我的想象。我知道 TS 很容易被滥用，并剥夺编程的乐趣，但私以为如果 TS 使用得当，它可以增强我们作为程序员阅读代码的主要角色。强烈推荐批判性思维和 TSLint。</p><p>个人建议：静态类型优先选择 TS</p><h2>IDE（集成开发环境）</h2><p>有两个人气爆棚且平分秋色的选择：IntelliJ 和 VSCode。IntelliJ 不是免费的，但 Vue 是开箱即用的支持，而 VSCode 是免费且开源的，但需要额外的配置。如果您更喜欢 VSCode，请确保安装 Volar 和 TypeScript Vue Plugin（Volar），增强开发体验。</p><p>个人建议：IDE 优先选择 IntelliJ 或 VSCode</p><h2>API文档</h2><p>Swagger 是迄今为止人气最高的选择。它基于 OpenAPI 规范，可以轻松地与其他开发者共享 API 文档。这是一个成熟且得到良好支持的项目，背后有一个庞大的社区。</p><p>个人建议：API 文档优先选择 Swagger</p><h2>结语</h2><p>这些都是我在 2024 年使用 Vue 构建可扩展 App 的个人建议。机智如你可能已经察觉，大部分情况下我都喜欢坚持行业标准。私以为这可以与其他工具产生协同作用，并且它们的热度使得在 StackOverflow 上寻找错误变得更容易。举个栗子，偏离标准，比如实现自己的轻量级路由，一开始似乎是个好主意，但从长远来看，它肯定会导致比解决的问题更多的问题。</p>","id":7830128514090,"lookNum":695},{"title":"🔥 2024 推荐一款 Vue3 移动端模板 （⚠十个理由）","label":["VUE"],"time":"2024-03-18 03:31:27","uptime":"2024-03-18 03:31:27","creator":"风中追风","type":"tech","abstract":"我之前写过一篇 推荐一款基于Vue3的移动H5模板，加速你的移动应用开发，那篇文章介绍了我为什么做这个模板，简单讲当时 Vite 作为一款新的构建工具刚刚出来，还有Vue3也刚刚发布不久，社区里面关于中后台模板非常丰富，但是移动端的还很少，或者说做的不够好，所以那样一个契机下我从2022年一直开源到现在，也快两年时间了。 这个过程中，vue3-vant-mobile 也发布了 2.0 版本。新增了很多功能和示例，这是这篇文章的目的之一，讲讲新增了什么。第二个目的，2024年的时候，移动端模板也有很多了，不过我自认为我做的还算是可以的，所以我想推荐你用这一款。 需要强调的是移动端该有的东西，本文没有太多描述，它本该如此。介绍的是相对于其它模板的优势。希望的是收获更多关注，让模板有更多人使用。为了不让文章那么乏味，会有对比、会有思考，我们开始吧","logo":"https://img0.baidu.com/it/u=3548988512,2938760182&fm=253&fmt=auto&app=138&f=JPEG?w=800&h=500","content":"<h3>1. vue3生态 - 最好用的 DX 体验都有</h3><p>在模板早期的时候，它支持的事情不是很多，就是一个很普通的移动端模板，应该有的特性比如：移动端适配、Mock 数据模拟、VConsole 调试、Less 预处理器，默认内置的组件库，以及 vue3 全家桶里面的状态管理 Pinia、Router、setup、TS 支持等等。不过在 2.0 的时候，我增加了基于文件路由、组件自动引入、基于文件路由的布局系统、API自动导入、PWA（渐进式Web）、Unocss、PC 版心等等。这些新特性在使用 VS Code 编辑器进行业务开发，就会发现效率飞起。对了，Eslint 采用了antfu 的最新 eslint flat 插件配置，DX 体验更上一层楼。在同类项目当中，我发现这些特性要么就是没有集成、或者不全、甚至依赖版本滞后，但是这个模板一直在更新，使用最新最稳定的版本。</p><h3>2. vw 响应式、PC友好</h3><p>很多做前端的同学都知道，移动端适配这块有两种主流的方案，rem 和 vw, 不过基于 rem 的方案也说过是应对早期这种适配的解决方案，现在 vw 单位在众多浏览器支持度更好了，更建议使用 vw, 所以模板也是采用了这种实现。PC 友好又是什么呢？vw/vh 是一种视宽和视高的单位，基于浏览器窗体大小来的；而 rem 是基于文档头设置的font-size 决定的, 当用户在 PC 端打开你的移动端应用的时候，所有页面元素都会放大，导致很多交互都失效了，甚至个别元素不能操作。如果 rem 方案的话，我之前写过一款 rem-font-size 插件，可以设置一个版心，其实就是修改根字体大小，以及限制最大宽度，vw/vh适配 要多谢 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwswmsword%2Fpostcss-mobile-forever\" target=\"_blank\">postcss-mobile-forever</a> &nbsp;插件的作者给模板的一个PR，它也解决了 PC 版心的问题。所以这块的担心，也帮大家考虑到了。</p><h3>3. 贡献者最多</h3><p>项目是托管在 GITHUB 上的，目前为止，有10位小伙伴参与了贡献，其中一位在我合并代码时不小心给合并掉了，当时因为这件事很难受。其实这个项目的 Fork 有 118，不过真正参与的同学也就是10位，但是也是一个很不错的数字。今天刷到尤大的一个帖子。</p><p><br></p><p>然后底下有个评论很有意思。</p><p><br></p><p>是的，在项目的早期很小的时候，项目维护者是很希望有更多贡献者参与进来，哪怕是错别字一类的PR 提交，这是很令人兴奋的事情。同时，这也意味着更多人在使用，社区影响力也就越大。</p><p>下面是给 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FCharleeWa%2Fvue3-vant-mobile%3Ftab%3Dreadme-ov-file%23contributors\" target=\"_blank\">vue3-vant-mobile</a> 贡献的小伙伴，谢谢他们 。</p><p><br></p><h3>4. ESM 默认</h3><p>估计不少同学会笑起来，ESM 默认就是在package.json 设置 type: \"module\"？ 这也是一个优势吗？至少我认为是的， 从两方面说说。其中一方面是如果不设置项目类型，项目默认采用Commonjs 规范，在一个没有明确类型的项目里，可能存在两种 CJS 或者 ESM 写法，让当事人去维护感觉会很错乱。当我显式设置 ESM 项目类型以后，1.0 以前很多的模块引入写法以及包依赖就报了大量错误，所以升级到 2.0 是一大部分工作，相当于重写。另外一方面，可能使用的人无感知，就是本机会加快渲染，因为采用的是浏览器原生支持的模块加载机制更快了。所以这也算是一个优势！</p><h3>5. Vant 官方社区推荐</h3><p>模板内置了 Vant 组件库，我自认为这是移动端最好的组件库之一。有一天，我在看 Vant 官网文档的时候，突然发现我的这个模板项目被 Vant、Rspack 作者设置为了官网的生态之一，这一点很让我兴奋。好奇什么时候被添加进去的，所以我翻看了 commit 提交记录。</p><p><br></p><p>这是官网的 - <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fvant-ui.github.io%2Fvant%2F%23%2Fzh-CN%23she-qu-sheng-tai\" target=\"_blank\">补充</a>。</p><p><br></p><p>如果说他们愿意把这个项目放到他们官网生态里面，至少说明它还不错，可以给大家一个很好的示范。这好比一个非常有公信力的人给你一个人格背书，所以大家可以放心使用。</p><h3>6. 不断增加的演示和示例</h3><p>自 2.0 以后，项目增加了 unocss 示例、持久化 Pinia 演示、404页演示、重写了 Dark Mode，未来还会增加更多组件，以及高级组件。</p><p>刚截图的时候，发现9分钟前的时候有人提需求，哈哈哈哈！（谁给项目提一个PR 🎉 ~ ）</p><p>这是已经完成的工作，作者很认真做开源。</p><h3>7. TS纯度 63+</h3><p>TS 语言的好处是不言而喻的，不只是提前发现类型错误问题，还有类型推导这种方便的特性。我之前为了快速完成一个 demo 没有使用 ts, 我突然意识到我都快不会写 js 项目了 😓。总之，真的很香！如果模板示例增多的话，Vue 语言应该会占更大部分，目前 TS 多，是因为不少配置文件。</p><h3>8. 星星 570+</h3><p>我以前的想法 100+ 就很满足了，但是后来就像滚雪球一样，大家都在用的时候，你发现你要做的更好。继续加油！<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FCharleeWa%2Fvue3-vant-mobile\" target=\"_blank\">给我鼓励 ⭐</a> 。</p><h3>9. 代码性能评分100%</h3><p>最近，我使用 lighthourse 工具分析了这个模板，把所有细节重新优化了一下，大家可以看到跑分还是不错的。</p><h3>10. 大佬关注</h3><p>有 Vant 、Rspack 作者，还有大圣老师，他们都在关注。</p><p><br></p>","id":31229246375886,"lookNum":6171},{"title":"前端全栈必须会的Prisma！","label":["代码人生","NEXTJS"],"time":"2024-04-14 13:49:24","uptime":"2024-04-14 13:49:24","creator":"风中追风","type":"recommend","abstract":"在这个快速迭代的数字时代，开发者们始终在寻找能够提高数据库操作效率和准确性的工具。 Prisma，应运而生。Prisma最初是作为一款图形QL数据库工具诞生的，随着时间的推移，它演变成了一个强大的数据库工具集，旨在解决传统ORM工具中存在的性能瓶颈和复杂性问题。 与传统的ORM工具相比，Prisma在易用性、性能和类型安全上提供了显著的优势。它不仅简化了数据库操作，而且提高了开发效率和应用性能。  ","logo":"https://www.qoqi.physik.uni-mainz.de/files/2014/10/prisma_logo_RGB_pos-1024x393.jpg","content":"<p>Prisma提供了一系列令人印象深刻的特性，包括但不限于：</p><ul><li><strong>自动生成的数据库访问客户端：</strong> 这让开发者可以避免编写重复的数据库CRUD操作代码。</li><li><strong>直观的数据模型设计：</strong> 使用Prisma Schema Language，开发者可以轻松定义应用数据模型。</li><li><strong>智能的类型安全：</strong> 它利用强大的类型系统，确保代码的稳定性和减少运行时错误。</li><li><strong>迁移系统：</strong> Prisma Migrate允许开发者安全地变更数据库结构。<br></li></ul><h1 style=\"text-align: start;\">上手</h1><p style=\"text-align: start;\">接下来我以用的最多的Mysql数据库为例开始演示，如何在项目里使用Prisma，请先确保安装好了nodejs环境。</p><h2 style=\"text-align: start;\">依赖</h2><p style=\"text-align: start;\">进入代码库，安装prisma依赖，并生成prisma文件夹和.env文件：</p><pre><code >npm install prisma\r\nnpx prisma init</code></pre><h2 style=\"text-align: start;\">连接数据库</h2><p style=\"text-align: start;\">打开.env设置对应数据库链接和用户名密码等信息：</p><pre style=\"text-align: start;\"><code class=\"language-hljs language-ini code-block-extension-codeshownum\">DATABASE_URL=\"mysql://johndoe:randompassword@localhost:5432/mydb?schema=public\"</code></pre><p>在<strong>prisma/schema.prisma中修改：</strong></p><pre><code >datasource db {\r\n  provider = \"mysql\"\r\n  url      = env(\"DATABASE_URL\")\r\n}</code></pre><h2 style=\"text-align: start;\">模型映射<br></h2><p>假设我们正在开发一款博客应用，有以下结构体：</p><pre><code >model Post {\n  id        Int      @id @default(autoincrement())\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  title     String   @db.VarChar(255)\n  content   String?\n  published Boolean  @default(false)\n  author    User     @relation(fields: [authorId], references: [id])\n  authorId  Int\n}\n\nmodel Profile {\n  id     Int     @id @default(autoincrement())\n  bio    String?\n  user   User    @relation(fields: [userId], references: [id])\n  userId Int     @unique\n}\n\nmodel User {\n  id      Int      @id @default(autoincrement())\n  email   String   @unique\n  name    String?\n  posts   Post[]\n  profile Profile?\n}</code></pre><p>我们可以直接将上述模型定义，转换为数据库指令，进行数据库表的修改：</p><pre><code >npx prisma migrate dev --name init\r</code></pre><p>等同于如下SQL表：</p><pre><code >CREATE TABLE \"Post\" (\n  \"id\" SERIAL,\n  \"createdAt\" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  \"updatedAt\" TIMESTAMP(3) NOT NULL,\n  \"title\" VARCHAR(255) NOT NULL,\n  \"content\" TEXT,\n  \"published\" BOOLEAN NOT NULL DEFAULT false,\n  \"authorId\" INTEGER NOT NULL,\n  PRIMARY KEY (\"id\")\n);\n\nCREATE TABLE \"Profile\" (\n  \"id\" SERIAL,\n  \"bio\" TEXT,\n  \"userId\" INTEGER NOT NULL,\n  PRIMARY KEY (\"id\")\n);\n\nCREATE TABLE \"User\" (\n  \"id\" SERIAL,\n  \"email\" TEXT NOT NULL,\n  \"name\" TEXT,\n  PRIMARY KEY (\"id\")\n);\n\nCREATE UNIQUE INDEX \"Profile.userId_unique\" ON \"Profile\"(\"userId\");\nCREATE UNIQUE INDEX \"User.email_unique\" ON \"User\"(\"email\");\nALTER TABLE \"Post\" ADD FOREIGN KEY(\"authorId\")REFERENCES \"User\"(\"id\") ON DELETE CASCADE ON UPDATE CASCADE;\nALTER TABLE \"Profile\" ADD FOREIGN KEY(\"userId\")REFERENCES \"User\"(\"id\") ON DELETE CASCADE ON UPDATE CASCADE;</code></pre><ul><li style=\"text-align: start;\">生成客户端<br></li></ul><p>现在我们要做的是，生成prisma客户端，你可以理解为官方提供的调用实例。</p><pre><code >npm install @prisma/client\r</code></pre><p style=\"text-align: start;\">安装命令会调用 <strong>prisma generate</strong> ，它会读取 Prisma schema并生成适合scheme的 Prisma 客户端版本。<br></p><p style=\"text-align: start;\">注意，每次修改prisma schema的时候，都需要执行<strong>prisma migrate dev</strong> 或 <strong>prisma db push。来保证云端数据库和代码里schema结构的同步。<br></strong></p><h2 style=\"text-align: start;\">CRUD</h2><p style=\"text-align: start;\">直接开始演示怎么进行增删改查吧！</p><p style=\"text-align: start;\">新建一个index.ts文件：</p><pre><code >import { PrismaClient } from '@prisma/client'\n\nconst prisma = new PrismaClient()\n\nasync function main() {\n  // ... you will write your Prisma Client queries here\n    const allUsers = await prisma.user.findMany()\n  console.log(allUsers)\n}\n\nmain()\n  .then(async () =&gt; {\n    await prisma.$disconnect()\n  })\n  .catch(async (e) =&gt; {\n    console.error(e)\n    await prisma.$disconnect()\n    process.exit(1)\n  })</code></pre><p>可以执行这个文件试试：</p><pre><code >npx ts-node index.ts\r</code></pre><p style=\"text-align: start;\">返回的是一个空数组，因为数据库里什么都没有····</p><p style=\"text-align: start;\">我们来尝试写入数据。</p><pre><code >async function main() {\n  await prisma.user.create({\n    data: {\n      name: 'Alice',\n      email: 'alice@prisma.io',\n      posts: {\n        create: { title: 'Hello World' },\n      },\n      profile: {\n        create: { bio: 'I like turtles' },\n      },\n    },\n  })\n\n  const allUsers = await prisma.user.findMany({\n    include: {\n      posts: true,\n      profile: true,\n    },\n  })\n  console.dir(allUsers, { depth: null })\n}</code></pre><p>还可以尝试更新：</p><pre><code >async function main() {\n  const post = await prisma.post.update({\n    where: { id: 1 },\n    data: { published: true },\n  })\n  console.log(post)\n}</code></pre><p><br></p><h1>感受</h1><p>在我个人使用Prisma的过程中，我深切体会到了它的便利性和高效性。</p><p>当然，任何技术都不是完美无缺的，我也遇到了一些挑战，但通过社区的帮助和官方文档，我总能找到解决方案。Prisma是面向未来的数据库工具集，它通过简化数据库操作，提高开发效率，并且不断创新，已经成为了许多现代应用开发的首选工具。</p><p>无论你是一个新手还是经验丰富的开发者，Prisma都值得一试。</p>","id":1713073764223,"lookNum":870},{"title":"如何让自己的前端知识更全面","label":["HTML5","JAVASCRIPT","REACT","VUE"],"time":"2024-04-14 13:51:35","uptime":"2024-04-14 13:51:35","creator":"风中追风","type":"recommend","abstract":"计算机知识庞大冗杂，尤其前端领域，知识概念，框架原理不断推崇出新。在学习的过程中我们要不断进行总结梳理，形成某一个知识领域的知识图谱。这个知识图谱还可以帮助我们后期进行回顾复习。","logo":"https://img1.baidu.com/it/u=2524728072,3579623438&fm=253&fmt=auto&app=138&f=PNG?w=436&h=309","content":"<p><br></p><ul><li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Ftsejx.github.io%2Fjavascript-guidebook%2F\" target=\"_blank\">JavaScript Guidebook</a>：JavaScript 知识图谱 – ECMAScript | DOM | BOM | HTML5 | 计算机网络 | 设计模式</li><li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Ftsejx.github.io%2Freact-guidebook%2F\" target=\"_blank\">React Guidebook</a>：：React 知识图谱 – 基本概念 | 进阶用法 | 框架生态 | 前沿技术 | 源码核心</li><li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Ftsejx.github.io%2Fwebpack-guidebook%2F\" target=\"_blank\">Webpack Guidebook</a>：：Webpack 知识图谱 – 模块化 | 基础概念 | 工作原理 | 实战应用</li><li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Ftsejx.github.io%2Fdevops-guidebook%2F\" target=\"_blank\">DevOps Guidebook</a>：：DevOps 知识图谱 – Linux | Nginx | 数据库 | 部署 | DevOps</li><li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Ftsejx.github.io%2Fvue-guidebook%2F\" target=\"_blank\">Vue Guidebook</a>：Vue 知识图谱 – 基本概念 | 响应式原理 | 编译原理 | 框架生态</li><li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Ftsejx.github.io%2Fcss-guidebook%2F\" target=\"_blank\">CSS Guidebook</a>：CSS 知识图谱 – 特性 | 属性 | 布局 | 响应式 | 动画</li><li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Ftsejx.github.io%2Fnode-guidebook%2F\" target=\"_blank\">Node Guidebook</a>：Node.js 知识图谱 – 模块 | 异步编程 | 进程 | I/O | 服务端应用</li><li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Ftsejx.github.io%2Ftypescript-guidebook%2F\" target=\"_blank\">TypeScript Guidebook</a>：TypeScript 知识图谱 – 静态类型检查 | 语法基础 | 配置使用 | 编译原理</li><li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Ftsejx.github.io%2Fcross-platform-guidebook%2F\" target=\"_blank\">Cross Platform Guidebook</a>：跨平台开发知识图谱 – HybridApp、ReactNative、小程序、Flutter、Electron</li><li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Ftsejx.github.io%2Fdata-structure-and-algorithms-guidebook%2F\" target=\"_blank\">Data Structure and Algorithms Guidebook</a>：数据结构与算法知识图谱 – 数据结构 | 算法 | 编程实现</li><li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Ftsejx.github.io%2Fvisualization-guidebook%2F\" target=\"_blank\">Visualizaition Guidebook</a>：前端图像学知识图谱 – Canvas | SVG | WebGL</li><li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Ftsejx.github.io%2Fdatabase-guidebook%2F\" target=\"_blank\">Database Guidebook</a>：MySQL、MongoDB</li></ul><p>要想自己的前端知识学的扎实，我们就一定要形成这样一个个知识图谱，里面从基础概念到应用到原理，让自己的知识脉络形成一张网，然后我们不断地在这张网上进行修补或扩充。很多人觉得前端的知识点零碎杂就是因为没有形成这样的知识网，这样也容易导致开发中遇到问题的时候，不知道该往哪个方向去想。</p><p>平时写博客记录的是零碎的知识点，我们还要做一个这样的知识图谱站，系统去梳理某个知识领域的所有知识点。这个可以有效的去帮我们在面试前巩固知识点，从容应对！<br></p>","id":1713073895845,"lookNum":260},{"title":"深入浅出微前端","label":["代码人生","HTML5"],"time":"2024-04-14 13:59:17","uptime":"2024-04-14 13:59:17","creator":"风中追风","type":"recommend","abstract":"微前端的核心理念是将前端应用程序看作是一个整体，由多个独立的部分组成。每个部分被视为一个微前端应用，它们可以具有自己的技术栈、开发流程和团队组织。这种方式使得团队可以独立开发和部署各个子应用，减少了协调和合并的复杂性。","logo":"https://img1.baidu.com/it/u=1160064730,1797307352&fm=253&fmt=auto&app=138&f=JPEG?w=395&h=234","content":"<h1>为什么 Iframe 无法胜任微前端的工作？</h1><p>IFrame 在传统的前端开发中是一种常见的技术，用于在页面中嵌入其他网页或应用程序。然而，在微前端架构中，IFrame 并不是一个理想的选择，主要是因为以下几个方面的限制：</p><ol><li>隔离性和通信复杂性：IFrame 本身提供了一种隔离的环境，但这也带来了通信和数据交互的复杂性。由于每个子应用都在独立的 IFrames 中运行，它们之间的通信需要通过特定的机制，如消息传递，而这增加了开发和维护的复杂性。</li><li>性能和加载时间：每个 IFrames 都需要加载和渲染独立的 HTML、CSS 和 JavaScript。这意味着在加载微前端应用时，需要同时加载多个 IFrames，导致额外的网络请求和页面资源占用，可能会影响性能和加载时间。</li><li>样式和布局限制：IFrame 的内容在页面中是独立的，它们具有自己的 CSS 样式和布局上下文。这导致在微前端架构中难以实现全局样式的一致性，以及子应用之间的布局和交互的协调问题。</li><li>浏览器安全性限制：由于安全策略的限制，IFrame 之间的跨域通信可能受到限制，特别是在涉及跨域资源访问和共享数据时。这可能导致在微前端架构中需要处理复杂的安全性问题。</li></ol><p>鉴于以上限制，微前端架构通常采用其他技术手段来实现子应用的拆分和集成，例如使用 Web Components、JavaScript 模块加载器等。这些技术能够提供更好的隔离性、通信机制和性能优化，使得微前端架构更具可行性和灵活性。</p><h1>微前端运行原理</h1><ul><li>监听路由变化</li><li>匹配子应用</li><li>加载子应用</li><li>渲染子应用</li></ul><h2>监听路由变化</h2><ol><li>监听 hash 路由: window.onhashchange</li><li>监听 history 路由</li></ol><p>history.go、history.back、history.forward 使用 popstate 事件 <code>window.onpopstate</code></p><pre><code >监听的方式\nwindow.addEventListener('popstate', () =&gt; {})\r</code></pre><p><span style=\"color: var(--cyanosis-strong-color);\"><strong>重写</strong></span>: pushState、replaceState 需要通过函数重写的方式进行 <span style=\"color: var(--cyanosis-code-color); background-color: var(--cyanosis-code-bg-color);\"><code>劫持</code></span></p><pre><code >const rawPushState = window.history.pushState\nwindow.history.pushState = function(...args) {\n  rawPushState.apply(window.history, args)\n\n  // 其他逻辑\n}\n\nconst rawReplaceState = window.history.replaceState\nwindow.history.replaceState = function(...args) {\n  rawReplaceState.apply(window.history, args)\n\n  // 其他逻辑\n}</code></pre><p>在 Vue 项目中，我们通过 this.router.push会触发‘history.pushState‘事件，this.router.push 会触发 `history.pushState` 事件，this.router.push会触发‘history.pushState‘事件，this.router.replace 会触发 history.replaceState 事件。<br></p><p>监听路由的变化后，拿到当前路由的路径 <span style=\"color: var(--cyanosis-code-color); background-color: var(--cyanosis-code-bg-color);\"><code>window.location.pathname</code></span>，然后根据 registerMicroApps 的参数 <span style=\"color: var(--cyanosis-code-color); background-color: var(--cyanosis-code-bg-color);\"><code>apps</code></span> 查找子应用。因为子应用都配置了 <span style=\"color: var(--cyanosis-code-color); background-color: var(--cyanosis-code-bg-color);\"><code>activeRule</code></span>。</p><pre><code >// 如果当前的 pathname 以 activeRule 开头，表明匹配到了子应用\n\nconst currentApp = apps.find(app =&gt; window.location.pathname.startWith(app.activeRule))\n</code></pre><p>当我们找到了与当前路由匹配的子应用，接着就去加载这个子应用的资源。</p><pre><code >function handleRouter = async () =&gt; {\n  // 匹配子应用\n\n  // 加载资源\n  const html = await fetch(currentApp.entry.then(res =&gt; res.text())\n\n  // 将 html 渲染到指定的容器内\n  const container = document.querySelector(currentApp.container)\n}</code></pre><p><br></p><p>这个时候，我们就拿到了子应用的 <code>html</code> 文本。</p><p>但是我们不能给直接通过 <code>container.innerHTML = html</code> 将文本放到容器内，这样是无法显示的。</p><p><strong>注意</strong> 浏览器处于安全考虑，放到页面上的 html 如果包含了 js 脚本，它是不会去执行 js 的。我们需要手动处理 <code>script</code> 脚本。<br></p><h2>importHTML 加载资源/处理脚本</h2><p>我们来封装一个函数 <code>importHTML</code>，专门来处理 <code>html</code> 文本。(<code>qiankun内部引用的 import-html-entry 就是做这个事的。</code>)</p><p>我们可以把加载子应用资源的 fetch 请求放到 importHTML 函数中，它还有如下几个功能：</p><ul><li>将获取到的 html 文本，放到 template DOM节点中</li><li>获取所有的 Script 脚本</li><li>执行所有的 Script 脚本<br></li></ul><pre><code >export const importHTML = url =&gt; {\n  const html = await fetch(currentApp.entry).then(res =&gt; res.text()\n\n  const template = document.createElement('div')\n\n  template.innerHTML = html\n\n  const scripts = template.querySelectAll('script')\n\n  const getExternalScripts = () =&gt; {\n    console.log('解析所有脚本: ', scripts)\n  }\n\n  const execScripts = () =&gt; {}\n\n  return {\n    template, // html 文本\n    getExternalScripts, // 获取 Script 脚本\n    execScripts, // 执行 Sript 脚本\n  }\n}\n</code></pre><p><br></p><p>script 脚本分为 <code>内联</code> 脚本和外链脚本，这里需要分开处理，拿到内联脚本后，获取内容可以通过 <code>eval</code> 直接处理。如果是含有 <code>scr</code> 的 script 脚本，还需要拿到 src 的值，通过 <code>fetch</code> 去加载脚本。</p><pre><code >我们在 getExternalScripts 方法中来处理\nconst getExternalScripts = async () =&gt; {\n  return Promise.all(Array.from(scripts).map(script =&gt; {\n    // 获取 scr 属性\n    const src = script.getAttribute('src')\n\n    if (!src) {\n      return Promise.resolve(script.innerHTML)\n    } else {\n      return fetch(src.startWith('http') ? src : `${url}${src}`).then(res =&gt; res.text())\n    }\n  }))\n}\n</code></pre><p>然后我们就可以通过 <span style=\"color: var(--cyanosis-code-color); background-color: var(--cyanosis-code-bg-color);\"><code>execScripts</code></span> 方法去调用 getExternalScripts，拿到所有的脚本内容后，执行！</p><pre><code >const execScripts = async () =&gt; {\n  const scripts = await getExternalScripts() \n\n  scripts.forEach(code =&gt; {\n    eval(code)\n  })\n}\n</code></pre><p><br></p>","id":1713074357764,"lookNum":9319},{"title":"解锁 JSON.stringify() 5 个鲜为人知的功能","label":["HTML5","JAVASCRIPT"],"time":"2024-04-14 14:03:42","uptime":"2024-04-14 14:04:38","creator":"风中追风","type":"tech","abstract":"JSON.stringify()作为常用的前端格式化方法，你知道这个5个功能吗","logo":"https://img2.baidu.com/it/u=4219270492,3071222208&fm=253&fmt=auto&app=138&f=JPEG?w=561&h=489","content":"<p><span style=\"color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 15px;\">你可能熟悉</span>JSON.stringify()<span style=\"color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 15px;\">方法，通常用于调试。但是很多只是简单使用一下接下来，让我们深入了解其实用性。</span></p><p>考虑一个对象如果想把她转成字符串打印出来：</p><pre><code >const obj = {  \n    name: 'San Shang You Ya',  \n    age: 18  \n};  \nconsole.log(obj.toString()); // Result: [object Object]\n</code></pre><p style=\"text-align: start;\">如果你想这样打印你所看到的只能是 <span style=\"color: rgb(62, 175, 124); background-color: rgba(27, 31, 35, 0.05);\"><code>[object Object]</code></span></p><p style=\"text-align: start;\">我们可以借助<span style=\"color: rgb(62, 175, 124); background-color: rgba(27, 31, 35, 0.05);\"><code>JSON.stringify()</code></span>方法</p><pre><code >const obj = {  \n    name: 'San Shang You Ya',  \n    age: 18  \n};  \nconsole.log(JSON.stringify(obj)); \n// Result: {\"name\":\"San Shang You Ya\",\"age\":18}</code></pre><p style=\"text-align: start;\">大多数开发者直接使用 JSON.stringify()，但我即将揭示一些隐藏的技巧。<br></p><h2 style=\"text-align: start; line-height: 1.5;\">1. 第二个参数(Array)<br></h2><p>-JSON.stringify() 接受第二个参数，它是一个你想在控制台中显示的对象的键的数组。例如：</p><pre><code >const obj = {  \n    name: 'San Shang You Ya',  \n    age: 18  \n};  \nconsole.log(JSON.stringify(obj, ['name']));  \n// Result: {\"name\": \"San Shang You Ya\"}\n</code></pre><p style=\"text-align: start;\">这样而不是将整个 <span style=\"color: rgb(62, 175, 124); background-color: rgba(27, 31, 35, 0.05);\"><code>JSON</code></span> 对象混乱地显示在控制台中，可以通过将所需的键作为数组传递给第二个参数来选择性地打印。<br></p><h2 style=\"text-align: start; line-height: 1.5;\">2. 第二个参数(Function)<span style=\"color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 15px;\"><br></span></h2><ul><li style=\"text-align: start;\">第二个参数也可以是一个函数，根据函数内的逻辑输出键值对。</li><li style=\"text-align: start;\">如果返回 undefined，则该键值对将不会被打印出来</li></ul><pre><code >const obj = {  \n    name: 'San Shang You Ya',  \n    age: 18  \n};  \n  \nconsole.log(JSON.stringify(obj, (key, value) =&gt; (key === \"age\" ? value : undefined)));\n// Result: {\"age\": 18}\n</code></pre><h2 style=\"text-align: start; line-height: 1.5;\">3. 第三个参数作为数字<span style=\"color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); font-size: 15px;\"><br></span></h2><ul><li>第三个参数控制最终字符串中的间距。如果是一个数字，字符串化的每个级别将相应缩进。</li></ul><pre><code >const obj = {  \n    name: 'San Shang You Ya',  \n    age: 18  \n};  \nconsole.log(JSON.stringify(obj, null, 2));</code></pre><p><img src=\"https://img2.baidu.com/it/u=4219270492,3071222208&fm=253&fmt=auto&app=138&f=JPEG?w=561&h=489\" alt=\"desc\" data-href=\"https://img2.baidu.com/it/u=4219270492,3071222208&fm=253&fmt=auto&app=138&f=JPEG?w=561&h=489\" style=\"\"/></p><h2 style=\"text-align: start; line-height: 1.5;\">4. 第三个参数作为字符串<br></h2><p style=\"text-align: start;\">如果第三个参数是一个字符串，它将替换为空格字符<br></p><h2 style=\"text-align: start; line-height: 1.5;\">5. toJSON 方法<br></h2><p>对象可以拥有一个 <span style=\"color: rgb(62, 175, 124); background-color: rgba(27, 31, 35, 0.05);\"><code>toJSON</code></span> 方法。 <span style=\"color: rgb(62, 175, 124); background-color: rgba(27, 31, 35, 0.05);\"><code>JSON.stringify()</code></span> 返回该方法的结果，并对其进行字符串化，而不是转换整个对象。</p><pre><code >const superhero= {  \n    firstName: \"San Shang\",  \n    lastName: \"You Ya\",  \n    age: 21,  \n    toJSON() {  \n        return {  \n            fullName: `${this.firstName} + ${this.lastName}`  \n        };  \n    }  \n};  \n</code></pre><p><br></p>","id":1713074622022,"lookNum":6685},{"title":"28个Javascript数组方法，开发者的小抄","label":["JAVASCRIPT"],"time":"2024-04-14 14:18:47","uptime":"2024-04-14 14:18:47","creator":"风中追风","type":"recommend","abstract":"最近面试有道题是至少写出 15 个数组方法，数组方法平时经常用到的也就6-7个，突然要一下子写出15个，还是有点卡壳了，今天整理一波，日后好复习。","logo":"https://img2.baidu.com/it/u=3423392000,2004693325&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=360","content":"<h3 style=\"text-align: start;\">Array.map()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>map()</code></span> 方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。</p><pre><code >const list = [😫, 😫, 😫, 😫];\nlist.map((⚪️) =&gt; 😀); // [😀, 😀, 😀, 😀]\n\nconst list = [1, 2, 3, 4];\nlist.map((el) =&gt; el * 2); // [2, 4, 6, 8]\n</code></pre><h3 style=\"text-align: start;\">Array.filter()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>filter()</code></span> 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。</p><pre><code >const list = [😀, 😫, 😀, 😫];\nlist.filter((⚪️) =&gt; ⚪️ === 😀); // [😀, 😀]\n\n// Code\nconst list = [1, 2, 3, 4];\nlist.filter((el) =&gt; el % 2 === 0); // [2, 4]\n</code></pre><h3 style=\"text-align: start;\">Array.reduce()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>reduce()</code></span> 方法对数组中的每个元素按序执行一个由您提供的 <span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>reducer</code></span> 函数，每一次运行 <span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>reducer</code></span> 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。</p><pre><code >const list = [😀, 😫, 😀, 😫, 🤪];\nlist.reduce((⬜️, ⚪️) =&gt; ⬜️ + ⚪️); // 😀 + 😫 + 😀 + 😫 + 🤪\n\n// OR\nconst list = [1, 2, 3, 4, 5];\nlist.reduce((total, item) =&gt; total + item, 0); // 15\n</code></pre><h3 style=\"text-align: start;\">Array.reduceRight()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>reduceRight()</code></span> 方法的功能和 <span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>reduce()</code></span> 功能是一样的，不同的是 <span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>reduceRight()</code></span> 从数组的末尾向前将数组中的数组项做累加。</p><pre><code >const list = [😀, 😫, 😀, 😫, 🤪];\nlist.reduceRight((⬜️, ⚪️) =&gt; ⬜️ + ⚪️); // 🤪 + 😫 + 😀 + 😫 + 😀\n\n// Code\nconst list = [1, 2, 3, 4, 5];\nlist.reduceRight((total, item) =&gt; total + item, 0); // 15\n</code></pre><h3 style=\"text-align: start;\">Array.fill()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>fill()</code></span> 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。</p><pre><code >const list = [😀, 😫, 😀, 😫, 🤪];\nlist.fill(😀); // [😀, 😀, 😀, 😀, 😀]\n\n\nconst list = [1, 2, 3, 4, 5];\nlist.fill(0); // [0, 0, 0, 0, 0]\n</code></pre><h3 style=\"text-align: start;\">Array.find()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>find()</code></span> 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 <span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>undefined</code></span>。</p><pre><code >const list = [😀, 😫, 😀, 😫, 🤪];\nlist.find((⚪️) =&gt; ⚪️ === 😀); // 😀\nlist.find((⚪️) =&gt; ⚪️ === 😝); // undefined\n\n\nconst list = [1, 2, 3, 4, 5];\nlist.find((el) =&gt; el === 3); // 3\nlist.find((el) =&gt; el === 6); // undefined\n</code></pre><h3 style=\"text-align: start;\">Array.indexOf()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>indexOf()</code></span> 方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回<span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>-1</code></span>。</p><pre><code >const list = [😀, 😫, 😀, 😫, 🤪];\nlist.indexOf(😀); // 0\nlist.indexOf(😡); // -1\n\n// Code\nconst list = [1, 2, 3, 4, 5];\nlist.indexOf(3); // 2\nlist.indexOf(6); // -1\n</code></pre><h3>Array.lastIndexOf()</h3><pre><code >arr.lastIndexOf(searchElement[, fromIndex])\r\n</code></pre><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>lastIndexOf()</code></span> 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 <span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>fromIndex</code></span> 处开始。</p><pre><code >const list = [😀, 😫, 😀, 😫, 🤪];\nlist.lastIndexOf(😀); // 3\nlist.lastIndexOf(😀, 1); // 0\n\n// Code\nconst list = [1, 2, 3, 4, 5];\nlist.lastIndexOf(3); // 2\nlist.lastIndexOf(3, 1); // -1\n</code></pre><h3 style=\"text-align: start;\">Array.findIndex()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>findIndex()</code></span> 方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回<span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>-1</code></span>。</p><pre><code >const list = [😀, 😫, 😀, 😫, 🤪];\nlist.findIndex((⚪️) =&gt; ⚪️ === 😀); // 0\n\n// You might be thinking how it's different from `indexOf` 🤔\nconst array = [5, 12, 8, 130, 44];\narray.findIndex((element) =&gt; element &gt; 13); // 3\n\n// OR\nconst array = [{\n  id: 😀\n}, {\n  id: 😫\n}, {\n  id: 🤪\n}];\n\narray.findIndex((element) =&gt; element.id === 🤪); // 2\n\n</code></pre><h3 style=\"text-align: start;\">Array.includes()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>includes()</code></span> 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 <span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>true</code></span>，否则返回 <span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>false</code></span>。</p><pre><code >const list = [😀, 😫, 😀, 😫, 🤪];\nlist.includes(😀); // true\n\n// Code\nconst list = [1, 2, 3, 4, 5];\nlist.includes(3); // true\nlist.includes(6); // false\n</code></pre><h3 style=\"text-align: start;\">Array.pop()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>pop()</code></span> 方法从数组中删除最后一个元素，并返回该元素的值。此方法会更改数组的长度。</p><pre><code >const list = [😀, 😫, 😀, 😫, 🤪];\nlist.pop(); // 🤪\nlist; // [😀, 😫, 😀, 😫]\n\n// Code\nconst list = [1, 2, 3, 4, 5];\nlist.pop(); // 5\nlist; // [1, 2, 3, 4]\n</code></pre><h3 style=\"text-align: start;\">Array.push()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>push()</code></span> 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。</p><pre><code >const list = [😀, 😫, 😀, 😫, 🤪];\nlist.push(😡); // 5\nlist; // [😀, 😫, 😀, 😫, 🤪, 😡]\n\n// Code\nconst list = [1, 2, 3, 4, 5];\nlist.push(6); // 6\nlist; // [1, 2, 3, 4, 5, 6]\n</code></pre><h3 style=\"text-align: start;\">Array.shift()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>shift()</code></span> 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。</p><pre><code >const list = [😀, 😫, 😀, 😫, 🤪];\nlist.shift(); // 😀\nlist; // [😫, 😀, 😫, 🤪]\n// Code\nconst list = [1, 2, 3, 4, 5];\nlist.shift(); // 1\nlist; // [2, 3, 4, 5]\n</code></pre><h3 style=\"text-align: start;\">Array.unshift()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>unshift()</code></span> 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。</p><pre><code >const list = [😀, 😫, 😀, 😫, 🤪];\nlist.unshift(😡); // 6\nlist; // [😡, 😀, 😫, 😀, 😫, 🤪]\n\n// Code\nconst list = [1, 2, 3, 4, 5];\nlist.unshift(0); // 6\nlist; // [0, 1, 2, 3, 4, 5]</code></pre><h3 style=\"text-align: start;\">Array.splice()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>splice()</code></span> 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。</p><pre><code >const list = [😀, 😫, 😀, 😫, 🤪];\nlist.splice(1, 2); // [😀, 😫]\nlist; // [😀, 😫, 🤪]\n\n// Code\nconst list = [1, 2, 3, 4, 5];\nlist.splice(1, 2); // [2, 3]\nlist; // [1, 4, 5]</code></pre><h3 style=\"text-align: start;\">Array.slice()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>slice()</code></span> 方法返回一个新的数组对象，这一对象是一个由 <span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>begin</code></span> 和 <span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>end</code></span> 决定的原数组的浅拷贝（包括 <span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>begin</code></span>，不包括<span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>end</code></span>）。原始数组不会被改变。</p><pre><code >const list = [😀, 😫, 😀, 😫, 🤪];\nlist.slice(1, 3); // [😫, 😀]\nlist; // [😀, 😫, 😀, 😫, 🤪]\n\n// Code\nconst list = [1, 2, 3, 4, 5];\nlist.slice(1, 3); // [2, 3]\nlist; // [1, 2, 3, 4, 5]</code></pre><h3 style=\"text-align: start;\">Array.join()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>join()</code></span> 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。</p><pre><code >const list = [😀, 😫, 😀, 😫, 🤪];\nlist.join('〰️'); // \"😀〰️😫〰️😀〰️😫〰️🤪\"\n\n// Code\nconst list = [1, 2, 3, 4, 5];\nlist.join(', '); // \"1, 2, 3, 4, 5\"\n</code></pre><h3 style=\"text-align: start;\">Array.reverse()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>reverse()</code></span> 方法将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。该方法会改变原数组。</p><pre><code >const list = [😀, 😫, 😀, 😫, 🤪];\nlist.reverse(); // [🤪, 😫, 😀, 😫, 😀]\nlist; // [🤪, 😫, 😀, 😫, 😀]\n\n// Code\nconst list = [1, 2, 3, 4, 5];\nlist.reverse(); // [5, 4, 3, 2, 1]\nlist; // [5, 4, 3, 2, 1]\n</code></pre><h3 style=\"text-align: start;\">Array.sort()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>sort()</code></span> 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的。</p><pre><code >const list = [😀, 😫, 😀, 😫, 🤪];\nlist.sort(); // [😀, 😀, 😫, 😫, 🤪]\n\n// This make more sense 🤔\nconst array = ['D', 'B', 'A', 'C'];\narray.sort(); // 😀 ['A', 'B', 'C', 'D']\n\n// OR\nconst array = [4, 1, 3, 2, 10];\narray.sort(); // 😧 [1, 10, 2, 3, 4]\narray.sort((a, b) =&gt; a - b); // 😀 [1, 2, 3, 4, 10]\n</code></pre><h3 style=\"text-align: start;\">Array.some()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>some()</code></span> 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。</p><pre><code >const list = [😀, 😫, 😀, 😫, 🤪];\nlist.some((⚪️) =&gt; ⚪️ === 😀); // true\nlist.some((⚪️) =&gt; ⚪️ === 😡); // false\n\n// Code\nconst list = [1, 2, 3, 4, 5];\nlist.some((el) =&gt; el === 3); // true\nlist.some((el) =&gt; el === 6); // false\n</code></pre><h3 style=\"text-align: start;\">Array.every()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>every()</code></span> 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。</p><pre><code >const list = [😀, 😫, 😀, 😫, 🤪];\nlist.every((⚪️) =&gt; ⚪️ === 😀); // false\n\nconst list = [😀, 😀, 😀, 😀, 😀];\nlist.every((⚪️) =&gt; ⚪️ === 😀); // true\n\n// Code\nconst list = [1, 2, 3, 4, 5];\nlist.every((el) =&gt; el === 3); // false\n\nconst list = [2, 4, 6, 8, 10];\nlist.every((el) =&gt; el%2 === 0); // true\n</code></pre><h3 style=\"text-align: start;\">Array.from()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>Array.from()</code></span> 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</p><pre><code >const list = 😀😫😀😫🤪;\nArray.from(list); // [😀, 😫, 😀, 😫, 🤪]\n\nconst set = new Set(['😀', '😫', '😀', '😫', '🤪']);\nArray.from(set); // [😀, 😫, 🤪]\n\nconst range = (n) =&gt; Array.from({ length: n }, (_, i) =&gt; i + 1);\nconsole.log(range(10)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n</code></pre><p><br></p><h3>Array.of()</h3><p><code>Array.of()</code> 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。</p><p><code>Array.of()</code> 和 Array 构造函数之间的区别在于处理整数参数：<code>Array.of(7)</code> 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个长度为7的空数组（注意：这是指一个有7个空位(empty)的数组，而不是由7个 <code>undefined</code> 组成的数组）。</p><pre><code >Array.of(7);       // [7]\nArray.of(1, 2, 3); // [1, 2, 3]\n\nArray(7);          // [ , , , , , , ]\nArray(1, 2, 3);    // [1, 2, 3]</code></pre><h3 style=\"text-align: start;\">Array.isArray()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>Array.isArray()</code></span> 用于确定传递的值是否是一个 Array。</p><pre><code >Array.isArray([😀, 😫, 😀, 😫, 🤪]); // true\nArray.isArray(🤪); // false\n\n// Code\nArray.isArray([1, 2, 3, 4, 5]); // true\nArray.isArray(5); // false\n</code></pre><h3 style=\"text-align: start;\">Array.at()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>at()</code></span> 方法接收一个整数值并返回该索引的项目，允许正数和负数。负整数从数组中的最后一个项目开始倒数。</p><pre><code >const list = [😀, 😫, 😀, 😫, 🤪];\nlist.at(1); // 😫\n\n// Return from last 🤔\nlist.at(-1); // 🤪\nlist.at(-2); // 😫\n\n// Code\nconst list = [1, 2, 3, 4, 5];\nlist.at(1); // 2\nlist.at(-1); // 5\nlist.at(-2); // 4\n</code></pre><h3>Array.copyWithin()</h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>copyWithin()</code></span> 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。</p><pre><code >arr.copyWithin(target[, start[, end]])\n\nconst list = [😀, 😫, 😀, 😫, 🤪];\nlist.copyWithin(1, 3); // [😀, 😀, 🤪, 😫, 🤪]\n\nconst list = [😀, 😫, 😀, 😫, 🤪];\nlist.copyWithin(0, 3, 4); // [😫, 😫, 😀, 😫, 🤪]\n\n// Code\nconst list = [1, 2, 3, 4, 5];\nlist.copyWithin(0, 3, 4); // [4, 2, 3, 4, 5]\n\r</code></pre><h3>Array.flat()</h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>flat()</code></span> 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p><pre><code >const list = [😀, 😫, [😀, 😫, 🤪]];\nlist.flat(Infinity); // [😀, 😫, 😀, 😫, 🤪]\n\n// Code\nconst list = [1, 2, [3, 4, [5, 6]]];\nlist.flat(Infinity); // [1, 2, 3, 4, 5, 6]\n</code></pre><h3 style=\"text-align: start;\">Array.flatMap()<br></h3><p><span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>flatMap()</code></span> 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 连着深度值为1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。</p><pre><code >const list = [😀, 😫, [😀, 😫, 🤪]];\nlist.flatMap((⚪️) =&gt; [⚪️, ⚪️ + ⚪️ ]); // [😀, 😀😀, 😫, 😫😫, 😀, 😀😀, 😫, 😫😫, 🤪, 🤪🤪]\n\n// Code\nconst list = [1, 2, 3];\nlist.flatMap((el) =&gt; [el, el * el]); // [1, 1, 2, 4, 3, 9]\n</code></pre><p><br></p>","id":1713075527740,"lookNum":1569},{"title":"别做老实人了！这才是 HR 喜欢听的离职原因！","label":["人生思考"],"time":"2024-05-05 01:32:59","uptime":"2024-05-05 01:34:33","creator":"风中追风","type":"life","abstract":"找工作面试被问离职原因，千万不要直接说出你为什么从上家公司离职的真实原因！！！当老实人要吃亏的！！！其实，大部分真实的离职原因都是每家公司或多或少会遇到的，但如果直接说出来，很可能会让面试官担心你入职后也会因为同样的原因离职哦！💢😉 所以，作为一个聪明的求职者，我们应该如何回答这个问题呢？","logo":"https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2021%2F0909%2F55b284e7j00qz5cqe000yc000hs007hc.jpg&thumbnail=660x2147483647&quality=80&type=jpg","content":"<p style=\"text-align: start;\">首先，让我们来看看这 <span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>6</code></span> 个常见的<span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>离职原因</code></span>❌，以及它们的<span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>“禁忌”</code></span>回答方式吧！🚫<br></p><h2 style=\"text-align: start;\">🎯 工资太低<br></h2><p style=\"text-align: start;\">🚫 禁忌回答：因为前公司给的工资太低了，我实在是受不了了。<br></p><h2 style=\"text-align: start;\">🎯 加班严重<br></h2><p style=\"text-align: start;\">🚫 禁忌回答：前公司加班太严重了，我身体都垮了。<br></p><h2 style=\"text-align: start;\">🎯 领导傻 X<br></h2><p style=\"text-align: start;\">🚫 禁忌回答：前领导简直就是个傻 X，根本不懂管理。<br></p><h2 style=\"text-align: start;\">🎯 被裁员<br></h2><p style=\"text-align: start;\">🚫 禁忌回答：我之前的公司裁员，我被无辜波及了。<br></p><h2 style=\"text-align: start;\">🎯 无法升职<br></h2><p style=\"text-align: start;\">🚫 禁忌回答：我在前公司干了几年，但一直升不上去。<br></p><h2 style=\"text-align: start;\">🎯 同事相处不和谐<br></h2><p style=\"text-align: start;\">🚫 禁忌回答：前公司的同事们都太奇葩了，我实在受不了。<br></p><hr/><p style=\"text-align: start;\">👀 看到了吗？这些回答都是大忌，因为它们会让 <span style=\"color: rgb(255, 80, 44); background-color: rgb(255, 245, 245);\"><code>HR</code></span> 觉得你不稳定、有负面情绪、甚至可能是个问题员工。那么，正确的回答方式是什么呢？别急，我们接着往下看！✅<br></p><p style=\"text-align: start;\"><br></p><h2> 🎯 工资太低</h2><p>✅ 回答模板：HR 您好!我过去 2 年，在公司和领导的帮助下，我在技术和能力方面有了很大提升，为公司开发的各种工具和库，极大地提高了项目开发效率，领导对我很认可，但公司的薪资结构有一些硬指标，无法满足我的涨薪需求，所以想看看市场上的新机会，寻找一个可以长期稳走发展的平台。<br></p><p><br></p><hr/><h2>🎯 加班严重</h2><p>✅ 回答模板：HR 您好!在上家公司，我的工作效率较高，能按时保质保量地完成工作，但前司会定期统计加班时长，并以此进行考核，导致大部分人为了加班而加班，效率非常低，我个人并不反对加班，但这种低效的常态化 996，我并不认可，我希望能在更人性化管理的公司里发挥优势。<br></p><p><br></p><hr/><h2> 🎯领导傻 X（这个有点难，但我们可以尽量委婉）</h2><p>✅ 回答模板：HR 您好!因为前公司的工作职贵划分比较固定，每个人负责的业务比较少，对于所负责的开发工作，我已经没有什么新知识可以学的了，我希望职业生涯是一个持续的学习和提升的过程，并且在自己具备了相关业务技能经验后，也想迎接一些新的挑战。<br></p><p><br></p><hr/><h2 style=\"text-align: start;\">🎯被裁员</h2><p style=\"text-align: start;\">✅ 回答模板：HR 您好!前公司当时在进行业务调整，公司想让我调到其他业务线上，岗位职责也发生了变化，我觉得自己还是很擅长做前端工具链方向的开发，并且也在这块积累了几年经验，还是想继续在这个方向上深耕，因此出来看看机会。</p><p style=\"text-align: start;\"><br></p><hr/><h2 style=\"text-align: start;\">🎯无法升职</h2><p style=\"text-align: start;\">✅ 回答模板：HR 您好!前公司管理比较扁平，虽然一直被领导重用，也负责过多个核心业务，但是职级几年来来一直没有变化。领导也争取过，但由于工作年限等原因，没能通过。我不想安于现状，想找一个更能发挥自己才能的平台。</p><p style=\"text-align: start;\"><br></p><hr/><h2 style=\"text-align: start;\">🎯 同事相处不和谐</h2><p style=\"text-align: start;\">✅ 回答模板：HR 您好!我之前在前司能力不错，取得了不错的成绩，但由于分工不太合理，出现了很多扯皮现象和低效沟通，影响到了工作效率，有时甚至会影响整个项目的进度，内耗较大，所以决定离开，希望找一个氛国好团队长期发展。</p><p style=\"text-align: start;\"><span style=\"color: rgb(37, 41, 51); background-color: rgb(255, 255, 255); font-size: 16px;\">💡 记住了吗？面试时回答离职原因的关键在于：</span>不要贬低前司和前同事<span style=\"color: rgb(37, 41, 51); background-color: rgb(255, 255, 255); font-size: 16px;\">、</span>不要让 HR 觉得是你的问题<span style=\"color: rgb(37, 41, 51); background-color: rgb(255, 255, 255); font-size: 16px;\">、</span>也不要吐槽前司的任何不足<span style=\"color: rgb(37, 41, 51); background-color: rgb(255, 255, 255); font-size: 16px;\">。掌握这些要领，相信你在面试中一定能够游刃有余地应对这个问题啦！</span></p><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\"><span style=\"color: rgb(102, 102, 102); background-color: rgb(248, 248, 248); font-size: 16px;\">如果觉得本文对你有帮助，希望能够给我点赞支持一下哦 💪，一起学习前端技能</span></p><p style=\"text-align: start;\"><br></p>","id":1714843979179,"lookNum":944},{"title":"前端性能优化","label":["JAVASCRIPT","SSR","NUSTJS","VUE","REACT","NEXTJS"],"time":"2024-05-05 01:41:45","uptime":"2024-05-05 01:44:22","creator":"风中追风","type":"recommend","abstract":"在当今数字时代，网站的性能对于吸引和保留用户至关重要。用户不愿意等待缓慢的加载时间，而快速响应的页面将帮助您留住访问者，提升转化率。前端性能优化是实现这一目标的关键因素之一。在本文中，我们将探讨一些重要的前端性能优化策略，以提高网站速度、交互性和用户满意度。","logo":"https://www.wenytao.com/zb_users/upload/2021/10/20211029111133163547709377251.jpeg","content":"<h1 style=\"text-align: center;\">为什么要做性能优化</h1><p style=\"text-align: start; line-height: 2;\">性能优化是为了提高网页的加载速度和相应速度，给用户带来更好的体验和用户满意度，同时还能减少服务器的负载压力，以此来提升程序的稳定性，具体有以下几个因素：</p><ul><li style=\"text-align: start; line-height: 2;\">提高用户体验</li><li style=\"text-align: start; line-height: 2;\">增加页面访问量</li><li style=\"text-align: start; line-height: 2;\">提高搜索引擎排名</li><li style=\"text-align: start; line-height: 2;\">减少服务器压力</li><li style=\"text-align: start; line-height: 2;\">节约成本</li><li style=\"text-align: start; line-height: 2;\">提高用户留存率</li></ul><h1 style=\"text-align: center;\">常见性能优化有哪些关键指标？</h1><ul><li><strong>首屏加载时间First Contentful Paint（FCP）</strong>：首次内容绘制时间，指浏览器首次绘制页面中至少一个文本、图像、非白色背景色的<code>canvas/svg</code>元素等的时间，代表页面首屏加载的时间点。</li><li><strong>首次绘制时间First Paint（FP）</strong>：首次绘制时间，指浏览器首次在屏幕上渲染像素的时间，代表页面开始渲染的时间点。</li><li><strong>最大内容绘制时间Largest Contentful Paint（LCP）</strong>：最大内容绘制时间，指页面上最大的可见元素（文本、图像、视频等）绘制完成的时间，代表用户视觉上感知到页面加载完成的时间点。</li><li><strong>用户可交互时间Time to Interactive（TTI）</strong>：可交互时间，指页面加载完成并且用户能够与页面进行交互的时间，代表用户可以开始操作页面的时间点。</li><li><strong>页面总阻塞时间Total Blocking Time (TBT)</strong>：页面上出现阻塞的时间，指在页面变得完全交互之前，用户与页面上的元素交互时出现阻塞的时间。TBT应该尽可能小，通常应该在300毫秒以内。</li><li><strong>搜索引擎优化Search Engine Optimization (SEO)</strong>：网站在搜索引擎中的排名和可见性。评分范围从0到100，100分表示网站符合所有SEO最佳实践。</li></ul><p>除此之外还有常见的<code>258</code>原则、<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fwww.51cto.com%2Farticle%2F755172.html\" target=\"_blank\"><code>GOOGLE</code>团队建议</a></p><p><strong>258原则</strong></p><ul><li><strong>2</strong>：页面的加载时间应该控制在2秒以内，这是用户能够接受的最短时间。</li><li><strong>5</strong>：页面的加载时间在5秒以内，用户对页面加载速度的不满意度开始上升。</li><li><strong>8</strong>：页面的加载时间超过8秒，用户的流失率将急剧增加，用户很可能会放弃访问该页面。<br></li></ul><h1 style=\"text-align: center;\">性能优化方式有哪些<br></h1><h2>HTML&CSS</h2><ul><li>减少<code>DOM</code>数量，减轻浏览器渲染计算负担。</li><li>使用异步和延迟加载<code>js</code>文件，避免<code>js</code>文件阻塞页面渲染</li><li>压缩<code>HTML、CSS</code>代码体积，删除不要的代码，合并<code>CSS</code>文件，减少<code>HTTP</code>请求次数和请求大小。</li><li>减少<code>CSS</code>选择器的复杂程度，复杂度与阿高浏览器解析时间越长。</li><li>避免使用<code>CSS</code>表达式在<code>javascript</code>代码中</li><li>使用<code>css</code>渲染合成层如<code>transform</code>、<code>opacity</code>、<code>will-change</code>等，提高页面相应速度减少卡顿现象。</li><li>动画使用<code>CSS3</code>过渡，减少动画复杂度，还可以使用硬件加速。<br></li></ul><p><br></p><h2>JS</h2><ul><li>减少<code>DOM</code>操作数量</li><li>避免使用<code>with</code>语句、<code>eval</code>函数，避免引擎难以优化。</li><li>尽量使用原生方法，执行效率高。</li><li>将<code>js</code>文件放到文件页面底部，避免阻塞页面渲染</li><li>使用事件委托，减少事件绑定次数。</li><li>合理使用缓存，避免重复请求数据。</li></ul><p><br></p><h2>Vue</h2><ul><li>合理使用<code>watch</code>和<code>computed</code>，数据变化就会执行，避免使用太多，减少不必要的开销</li><li>合理使用组件，提高代码可维护性的同事也会降低代码组件的耦合性</li><li>使用路由懒加载，在需要的时候才会进行加载，避免一次性加载太多路由，导致页面阻塞</li><li>使用<code>Vuex</code>缓存数据</li><li>合理使用<code>mixins</code>，抽离公共代码封装成模块，避免重复代码。</li><li>合理使用<code>v-if </code>、<code>v-show</code></li><li><code>v-for </code>不要和<code>v-if</code>一起使用，<code>v-for</code>的优先级会比<code>v-if</code>高</li><li><code>v-for</code>中不要用<code>index</code>做<code>key</code>，要保证<code>key</code>的唯一性</li><li>使用异步组件，避免一次性加载太多组件</li><li>避免使用<code>v-html</code>，存在安全问风险和性能问题，可以使用<code>v-text</code></li><li>使用<code>keep-alive</code>缓存组件，避免组件重复加载</li></ul><p><br></p><h2>Webpack优化</h2><ul><li>代码切割，使用<code>code splitting</code>将代码进行分割，避免将所有代码打包到一个文件，减少响应体积。</li><li>按需加载代码，在使用使用的时候加载代码。</li><li>压缩代码体积，可以减小代码体积</li><li>优化静态资源，使用字体图标、雪碧图、webp格式的图片、svg图标等</li><li>使用<code>Tree Shaking</code> 删除未被引用的代码</li><li>开启<code>gzip</code>压缩</li><li>静态资源使用<code>CDN</code>加载，减少服务器压力</li></ul><p><br></p><h2>网络优化</h2><ul><li>使用<code>HTTP/2</code></li><li>减少、合并<code>HTTP</code>请求，通过合并<code>CSS、JS</code>文件、精灵图等方式减少请求数量。</li><li>压缩文件， 开启<code>nginx</code>，<code>Gzip</code>对静态资源压缩</li><li>使用<code>HTTP</code>缓存，如强缓存、协商缓存</li><li>使用<code>CDN</code>，将网站资源分布到各地服务器上，减少访问延迟<br></li></ul><p><br></p><h1>图片懒加载原理</h1><p>图片懒加载也叫延迟加载，只加载当前屏幕的图片，可视区域外的图片不会进行加载，只有当屏幕滚动的时候才加载。</p><p><strong>特点</strong>：</p><ul><li>提高网页加载速度</li><li>减少后台服务器压力</li><li>提升用户体验</li></ul><h2>原理</h2><ul><li>将图片地址存储到 <code>data-xxx</code> 属性上</li><li>判断图片是否在可视区域</li><li>如果在，就设置图片 <code>src</code></li><li>绑定 <code>scroll</code> 监听事件</li></ul><h1>节流和防抖</h1><h2>节流</h2><p>节流是一种常用的性能优化技术，它可以限制函数的执行频率，避免过多的重复操作，提升页面的响应速度。</p><p><strong>函数在 n 秒内只执行一次，如果多次触发，则忽略执行。</strong></p><p><strong>应用场景</strong>：</p><ul><li>拖拽场景</li><li>scroll场景</li><li>窗口大小调整</li></ul><p>「<a href=\"https://juejin.cn/post/7272737742307065914#heading-5\" target=\"_blank\">手写代码-节流</a>」</p><p><br></p><h2>防抖</h2><p>防抖函数可以将多次高频率触发的函数执行合并成一次，并在指定的时间间隔后执行一次。通常在处理输入框、滚动等事件时使用，避免频繁触发事件导致页面卡顿等问题。</p><p><strong>函数在 n 秒后再执行，如果 n 秒内被触发，重新计时，保证最后一次触发事件 n 秒后才执行。</strong></p><p><strong>应用场景</strong>：</p><ul><li>输入框搜索</li><li>表单提交按钮</li><li>文本器保存</li></ul><p>「<a href=\"https://juejin.cn/post/7272737742307065914#heading-6\" target=\"_blank\">手写代码-防抖</a>」</p><p><br></p><h1>SPA首屏为什么加载慢？</h1><p><code>SPA</code>首屏加载慢可能有以下原因：</p><ul><li><strong>JavaScript文件过大</strong>：SPA通常有很多 JavaScript &nbsp;文件，如果这些文件的大小过大或加载速度慢，就会导致首屏加载缓慢。可以通过代码分割和打包、使用CDN等方式来优化加载速度。</li><li><strong>数据请求过多或数据请求太慢</strong>：SPA通过 AJAX 或 Fetch 等方式从后端获取数据，如果数据请求过多或数据请求太慢，也会导致首屏加载缓慢。可以通过减少数据请求、使用数据缓存、优化数据接口等方式来优化数据请求速度。</li><li><strong>大量图片加载慢</strong>：如果首屏需要加载大量图片，而这些图片大小过大或加载速度慢，也会导致首屏加载缓慢。可以通过图片压缩、使用图片懒加载等方式来优化图片加载速度。</li><li><strong>过多的渲染和重绘操作</strong>：如果在首屏加载时进行大量的渲染和重绘操作，也会导致首屏加载缓慢。可以通过尽可能少的DOM操作、使用CSS3动画代替JS动画等方式来优化渲染和重绘操作。</li><li><strong>网络问题</strong>：网络问题也会影响SPA首屏加载速度，比如网络延迟、丢包等。可以通过使用CDN、使用HTTP/2等方式来优化网络问题。<br></li></ul><p><br></p>","id":1714844505114,"lookNum":3055},{"title":"常用API分享","label":["JAVASCRIPT"],"time":"2024-05-06 01:04:39","uptime":"2024-05-06 01:07:28","creator":"风中追风","type":"life","abstract":"获取IP地址OSS裁剪，股票，天气等三方API","logo":"https://img0.baidu.com/it/u=2487547489,3131899055&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500","content":"<h1 style=\"text-align: center;\">常用API</h1><h3 style=\"text-align: start;\"><span style=\"color: rgb(29, 57, 196);\">获取IP地址搜狐接口</span></h3><p style=\"text-align: start;\"><a href=\"http://pv.sohu.com/cityjson?ie=utf-8\" target=\"_blank\">http://pv.sohu.com/cityjson?ie=utf-8</a></p><h3 style=\"text-align: start;\"><span style=\"color: rgb(29, 57, 196);\">OSS裁减</span></h3><p style=\"text-align: start;\"><a href=\"https://help.aliyun.com/document_detail/44693.html\" target=\"_blank\">https://help.aliyun.com/document_detail/44693.html</a></p><h3 style=\"text-align: start;\"><a href=\"https://help.aliyun.com/document_detail/44693.html\" target=\"_blank\"><span style=\"color: rgb(29, 57, 196);\">天气预报</span></a></h3><p style=\"text-align: start;\">获取城市ID</p><p style=\"text-align: start;\"><a href=\"http://mat1.gtimg.com/weather/index2014/wtData_v2.js\" target=\"_blank\">http://mat1.gtimg.com/weather/index2014/wtData_v2.js</a></p><p style=\"text-align: start;\"><a href=\"http://mat1.gtimg.com/weather/index2014/wtData_v2.js\" target=\"_blank\">根据城市ID获取天气</a></p><p style=\"text-align: start;\"><a href=\"http://wthrcdn.etouch.cn/WeatherApi?citykey=101010100\" target=\"_blank\">http://wthrcdn.etouch.cn/WeatherApi?citykey=101010100</a></p><p style=\"text-align: start;\"><a href=\"http://wthrcdn.etouch.cn/WeatherApi?citykey={cityID}\" target=\"_blank\">http://wthrcdn.etouch.cn/WeatherApi?citykey={cityID}</a></p><h3 style=\"text-align: start;\"><a href=\"http://wthrcdn.etouch.cn/WeatherApi?citykey={cityID}\" target=\"_blank\"><span style=\"color: rgb(29, 57, 196);\">股票类</span></a></h3><p style=\"text-align: start;\">上证指数</p><p style=\"text-align: start;\"><a href=\"http://qt.gtimg.cn/q=s_sh000001\" target=\"_blank\">http://qt.gtimg.cn/q=s_sh000001</a></p><p style=\"text-align: start;\"><a href=\"http://qt.gtimg.cn/q=s_sh000001\" target=\"_blank\">道琼斯指数</a></p><p style=\"text-align: start;\"><a href=\"http://qt.gtimg.cn/q=s_usDJI\" target=\"_blank\">http://qt.gtimg.cn/q=s_usDJI</a></p><p style=\"text-align: start;\">腾讯济安</p><p style=\"text-align: start;\"><a href=\"http://qt.gtimg.cn/q=s_sh000847\" target=\"_blank\">http://qt.gtimg.cn/q=s_sh000847</a></p><p style=\"text-align: start;\"><a href=\"http://qt.gtimg.cn/q=s_sh000847\" target=\"_blank\">恒生指数</a></p><p style=\"text-align: start;\"><a href=\"http://qt.gtimg.cn/q=s_r_hkHSI\" target=\"_blank\">http://qt.gtimg.cn/q=s_r_hkHSI</a></p><p style=\"text-align: start;\"><a href=\"http://qt.gtimg.cn/q=s_r_hkHSI\" target=\"_blank\">个股行情</a></p><p style=\"text-align: start;\"><a href=\"http://sqt.gtimg.cn/q=sh600519\" target=\"_blank\">http://sqt.gtimg.cn/q=sh600519</a></p><p style=\"text-align: start;\">http://sqt.gtimg.cn/q={股票代码}</p><p style=\"text-align: start;\">0: 未知 1: 股票名字 2: 股票代码 3: 当前价格 4: 昨收 5: 今开 6: 成交量（手） 7: 外盘 8: 内盘 9: 买一 10: 买一量（手） 11-18: 买二 买五 19: 卖一 20: 卖一量 21-28: 卖二 卖五 29: 最近逐笔成交 30: 时间 31: 涨跌 32: 涨跌% 33: 最高 34: 最低 35: 价格/成交量（手）/成交额 36: 成交量（手） 37: 成交额（万） 38: 换手率 39: 市盈率 40: 41: 最高 42: 最低 43: 振幅 44: 流通市值 45: 总市值 46: 市净率 47: 涨停价 48: 跌停价</p><h3 style=\"text-align: start;\"><span style=\"color: rgb(29, 57, 196);\">得到精美壁纸</span></h3><p style=\"text-align: start;\"><a href=\"http://cn.bing.com/iod/1366/1024/201706221600\" target=\"_blank\">http://cn.bing.com/iod/1366/1024/201706221600</a></p><p style=\"text-align: start;\">http://cn.bing.com/iod/1366/1024/{随机数}</p><p style=\"text-align: start;\">图片转BASE64</p><p style=\"text-align: start;\"><a href=\"https://c.runoob.com/front-end/59/\" target=\"_blank\">https://c.runoob.com/front-end/59/</a></p><h3 style=\"text-align: start;\"><a href=\"https://c.runoob.com/front-end/59/\" target=\"_blank\"><span style=\"color: rgb(29, 57, 196);\">WEB3有关</span></a></h3><p style=\"text-align: start;\">以太坊</p><p style=\"text-align: start;\">https://etherscan.io/</p><p style=\"text-align: start;\"><strong>领取Rinkeby链ETH</strong></p><p style=\"text-align: start;\"><a href=\"https://rinkebyfaucet.com/\" target=\"_blank\">https://rinkebyfaucet.com/</a><br><a href=\"https://blog.csdn.net/m0_37257009/article/details/95979365\" target=\"_blank\">https://blog.csdn.net/m0_37257009/article/details/95979365</a></p><p style=\"text-align: start;\">NFT藏品最大的交易平台</p><p style=\"text-align: start;\"><a href=\"https://opensea.io/\" target=\"_blank\">https://opensea.io/</a></p><p style=\"text-align: start;\">以太坊学习资料</p><p style=\"text-align: start;\"><a href=\"https://www.bookstack.cn/read/ethereum_book-zh/spilt.1.ee4988229e1934ea.md\" target=\"_blank\">https://www.bookstack.cn/read/ethereum_book-zh/spilt.1.ee4988229e1934ea.md</a></p><p style=\"text-align: start;\"><a href=\"https://www.bookstack.cn/read/ethereum_book-zh/spilt.1.ee4988229e1934ea.md\" target=\"_blank\"><strong>领取Sepolia链ETH</strong></a></p><p style=\"text-align: start;\"><strong> </strong><a href=\"https://polia-faucet.pk910.de/\" target=\"_blank\">https://polia-faucet.pk910.de/</a> </p><h3 style=\"text-align: start;\"><span style=\"color: rgb(9, 109, 217);\">TokenTool工具</span></h3><p> <a href=\"https://tokentools.app/\" target=\"_blank\">https://tokentools.app/</a> </p>","id":1714928679808,"lookNum":3855}]