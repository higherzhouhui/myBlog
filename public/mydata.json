[
  {
    "title": "十分钟学会WebSocket",
    "label": [
      "HTML5",
      "JAVASCRIPT"
    ],
    "time": "2024-18-03 00:43:51",
    "uptime": "2024-18-03 00:43:51",
    "creator": "风中追风",
    "type": "rencetly",
    "abstract": "WebSocket是一种在客户端和服务器之间实现双向通信的网络协议1。它通过在单个TCP连接上提供全双工通信功能，使得服务器可以主动向客户端推送数据，而不需要客户端发起请求。",
    "logo": "https://img0.baidu.com/it/u=248646428,2814622221&fm=253&fmt=auto&app=138&f=PNG?w=500&h=500",
    "content": "<h2 style=\"text-align: start;\">WebSocket与HTTP的区别</h2><p style=\"text-align: start;\">与传统的HTTP协议相比，WebSocket具有以下几个显著的区别：<span style=\"color: rgb(89, 89, 89); background-color: rgb(255, 255, 255); font-size: 15px;\"><br></span></p><p style=\"text-align: start;\"><br></p><li><strong>双向通信</strong>：WebSocket支持客户端和服务器之间的实时双向通信，而HTTP协议是单向请求-响应模式。</li><li><strong>低延迟</strong>：由于WebSocket使用长连接，避免了HTTP的连接建立和断开过程，可以降低通信延迟。</li><li><strong>更少的数据传输</strong>：WebSocket头部信息相对较小，减少了数据传输的开销。</li><li><strong>跨域支持</strong>：WebSocket可以轻松跨域，而HTTP需要通过CORS等机制来实现。<br></li><h2 style=\"text-align: start;\">WebSocket的工作原理<br></h2><p><br></p><p>WebSocket的握手过程和HTTP有所不同。客户端通过发送特定的HTTP请求进行握手，服务器收到请求后进行验证，如果验证通过，则会建立WebSocket连接。</p><p>建立连接后，客户端和服务器之间可以通过WebSocket发送和接收消息，可以使用文本、二进制数据等进行通信。<br></p><h2 style=\"text-align: start;\">WebSocket的应用场景<br></h2><p><br></p><p>WebSocket的实时双向通信特性使得它在许多应用场景中发挥重要作用，例如：</p><ul><li><strong>即时聊天</strong>：WebSocket可以实现实时的聊天功能，用户可以发送和接收消息，实现快速、低延迟的聊天体验。</li><li><strong>实时数据更新</strong>：对于需要实时更新数据的应用，如股票行情、实时监控等，WebSocket可以将数据实时推送给客户端，确保数据的及时更新。</li><li><strong>在线游戏</strong>：在线游戏需要实时的双向通信，WebSocket可以提供稳定的通信通道，支持实时交互和多人游戏。<br></li></ul><h2 style=\"text-align: start;\">WebSocket的使用</h2><pre style=\"text-align: start;\"><code class=\"language-hljs language-javascript code-block-extension-codeshownum\">var Socket = new WebSocket(\"url, [protocol]\");\n\n</code></pre><p style=\"text-align: start;\">以上代码中的第一个参数<span style=\"color: rgb(38, 198, 218); background-color: rgba(77, 208, 225, 0.08);\"><code>url</code></span>, 指定连接的 URL。第二个参数<span style=\"color: rgb(38, 198, 218); background-color: rgba(77, 208, 225, 0.08);\"><code>protocol</code></span>是可选的，指定了可接受的子协议。<br></p><h4 style=\"text-align: start;\">WebSocket 属性<br></h4><p style=\"text-align: start;\">以下是 WebSocket 对象的属性。<br></p><table style=\"width: auto;\"><tbody><tr><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">属性</th><th colSpan=\"1\" rowSpan=\"1\" width=\"auto\">描述</th></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Socket.readyState</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">只读属性readyState表示连接状态，可以是以下值：0-表示连接尚未建立。1-表示连接已建立，可以进行通信。2-表示连接正在进行关闭。3-表示连接已经关闭或者连接不能打开。</td></tr><tr><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">Socket.bufferedAmount</td><td colSpan=\"1\" rowSpan=\"1\" width=\"auto\">只读属性bufferedAmount已被send()放入正在队列中等待传输，但是还没有发出的UTF-8文本字节数。</td></tr></tbody></table><ul><li>0-表示连接尚未建立。</li><li>1-表示连接已建立，可以进行通信。</li><li>2-表示连接正在进行关闭。</li><li>3-表示连接已经关闭或者连接不能打开。<br></li></ul><h4 style=\"text-align: start;\">WebSocket 事件<br></h4><p style=\"text-align: start;\">以下是 WebSocket 对象的相关方法。</p><table style=\"width: auto; text-align: start;\"><tbody><tr><th colspan=\"1\" rowspan=\"1\" width=\"auto\">方法</th><th colspan=\"1\" rowspan=\"1\" width=\"auto\">描述</th></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">Socket.send()</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">使用连接发送数据</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">Socket.close()</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">关闭连接</td></tr></tbody></table><h2 style=\"text-align: start;\"><br></h2>",
    "id": 37740271083514,
    "lookNum": 1247
  },
  {
    "title": "2024年令人眼前一亮的Web框架",
    "label": [
      "JAVASCRIPT",
      "NEXTJS",
      "NUSTJS",
      "ANGULAR"
    ],
    "time": "2024-03-18 03:22:04",
    "uptime": "2024-03-18 03:22:04",
    "creator": "风中追风",
    "type": "rencetly",
    "abstract": "2024年正向我们走来，我们怀着满腔热情为新的一年制定计划，探索未来一年可以学习或实现的目标。此时此刻，正是探寻来年值得学习的框架、理解其功能和特色的最佳时刻。我们以2023年JS 新星名单为指引，力求保持客观公正的态度。对于每一个特色框架，我们都将突出其最大的优势，使您能够全面理解它们的优点，从而选择适合自己的框架进行尝试！   作者：腾讯TNTWeb前端团队 链接：https://juejin.cn/post/7339830464000213027 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",
    "logo": "https://pic.vjshi.com/2021-09-16/816586c10c974033982559cc1efbf52c/00003.jpg?x-oss-process=style/watermark",
    "content": "<p><br></p><p>为谁而设：</p><ul><li>你希望减少JavaScript的编写量</li><li>你希望代码更简单，以超媒体为中心</li></ul><p>HTMX在2023年迅速走红，过去一年间在GitHub上赢得了大量星标。HTMX并非普通的JS框架。如果你使用HTMX，你将大部分时间都花在超媒体的世界中，以与我们通常对现代Web开发的JS密集型视角完全不同的视角看待Web开发。<strong>HTMX利用HATEOAS（Hypermedia作为应用程序状态的引擎）的概念，使开发人员能够直接从HTML访问浏览器功能，而不是使用Javascript。</strong></p><p>此外，它还证明了通过发布令人惊叹的表情符号并以口碑作为主要营销手段，你可以获得人气和认可。不仅如此，你还可能成为HTMX的CEO！它吸引了许多开发人员尝试这种构建网站的方法，并重新思考他们当前的实践。所有这些都使2024年对于这个库的未来发展充满了激动人心的可能性。</p><h2>Wasp - 全栈，开箱即用🚀</h2><p>为谁而设：</p><ul><li>你希望快速构建全栈应用</li><li>你希望在一个出色的一体化解决方案中继续使用React和Node.js，而无需手动挑选堆栈的每一部分</li><li>你希望获得一个为React和Node.js预配置的免费SaaS模板—— <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwasp-lang%2Fopen-saas\" target=\"_blank\">Open SaaS</a></li></ul><p>对于希望简单轻松地全面控制其堆栈的工具的用户，无需再寻找！<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwasp-lang%2Fwasp\" target=\"_blank\">Wasp</a>是一个有主见的全栈框架，利用其编译器以快速简便的方式为你的应用创建数据库、后端和前端。它使用React、Node.js和Prisma，这些都是全栈Web开发人员正在使用的一些最著名的工具。</p><p>Wasp的核心是main.wasp文件，它作为你大部分需求的一站式服务。在其中，你可以定义：</p><ul><li>全栈身份验证</li><li>数据库架构</li><li>异步作业，无需额外的基础设施</li><li>简单且灵活的部署</li><li>全栈类型安全</li><li>发送电子邮件（Sendgrid、MailGun、SMTP服务器等）</li><li>等等……</li></ul><p>最酷的事情是？经过编译器步骤后，你的Wasp应用程序的输出是一个标准的React + Vite前端、Node.js后端和PostgreSQL数据库。从那里，你可以使用单个命令轻松将一切部署到Fly.io等平台。</p><p>尽管有些人可能会认为Wasp的有主见立场是负面的，但它却是Wasp众多全栈功能的驱动力。使用Wasp，单个开发人员或小型团队启动全栈项目变得更加容易，尤其是如果你使用预制的模板或OpenSaaS作为你的SaaS起点。由于项目的核心是定义明确的，因此开始一个项目并可能在几天内创建自己的全栈SaaS变得非常容易！</p><p><strong>此外，还有一点很酷的是，大多数Web开发人员对大多数现有技术的预先存在的知识仍然在这里适用，因为Wasp使用的技术已经成熟。</strong></p><h2>Solid.js - 一流的reactivity库 ↔️</h2><p>适合人群：</p><ul><li>如果你希望代码具有高响应性</li><li>现有的React开发人员，希望尝试一种对他们来说学习曲线较低的高性能工具</li></ul><p>Solid.js是一个性能很高的Web框架，与React有一些相似之处。例如，两者都使用JSX，采用基于函数的组件方法，但Solid.js不使用虚拟DOM，而是将你的代码转换为纯JavaScript。然而，Solid.js因其利用信号、备忘录和效果实现细粒度响应性的方法而更加出名。信号是Solid.js中最简单、最知名的基本元素。它们包含值及其获取和设置函数，使框架能够观察并在DOM中的确切位置按需更新更改，这与React重新渲染整个组件的方式不同。</p><p>Solid.js不仅使用JSX，还对其进行了增强。它提供了一些很酷的新功能，例如Show组件，它可以启用JSX元素的条件渲染，以及For组件，它使在JSX中更轻松地遍历集合变得更容易。另一个重要的是，它还有一个名为Solid Start的元框架（目前处于测试版），它使用户能够根据自己的喜好，使用基于文件的路由、操作、API路由和中间件等功能，以不同的方式渲染应用程序。</p><h2>Astro - 静态网站之王👑</h2><p>适合人群：</p><ul><li>如果您需要一款优秀的博客、CMS重型网站工具</li><li>需要一个能够集成其他库和框架的框架</li></ul><p>如果您在2023年构建了一个内容驱动的网站，那么很有可能您选择了Astro作为首选框架来实现这一目标！Astro是另一个使用不同架构概念来脱颖而出的框架。对于Astro来说，这是岛屿架构。在Astro的上下文中，岛屿是页面上的任何交互式UI组件，与静态内容的大海形成鲜明对比。由于这些岛屿彼此独立运行，因此页面可以有任意数量的岛屿，但它们也可以共享状态并相互通信，这非常有用。</p><p><strong>关于Astro的另一个有趣的事情是，他们的方法使用户能够使用不同的前端框架，如React、Vue、Solid来构建他们的网站。因此，开发人员可以轻松地在其当前知识的基础上构建网站，并利用可以集成到Astro网站中的现有组件。</strong></p><h2>Svelte - 简单而有效🎯</h2><p>适合人群：</p><ul><li>您希望学习一个简单易上手的框架</li><li>追求简洁且代码执行速度快的开发体验</li></ul><p><strong>Svelte是另一个尝试通过尽可能直接和初学者友好的方式来简化和加速Web开发的框架。它是一个很容易学习的框架，因为要使一个属性具有响应性，您只需声明它并在HTML模板中使用它。</strong> 每当在JavaScript中程序化地更新值时（例如，通过触发onClick事件按钮），它将在UI上反映出来，反之亦然。</p><p>Svelte的下一步将是引入runes。runes将是Svelte处理响应性的方式，使处理大型应用程序变得更加容易。类似于Solid.js的信号，符文通过使用类似函数的语句提供了一种直接访问应用程序响应性状态的方式。与Svelte当前的工作方式相比，它们将允许用户精确定义整个脚本中哪些部分是响应性的，从而使组件更加高效。类似于Solid和Solid Start，Svelte也有其自己的框架，称为SvelteKit。SvelteKit为用户提供了一种快速启动其由Vite驱动的Svelte应用程序的方式。它提供了路由器、构建优化、不同的渲染和预渲染方式、图像优化等功能。</p><h2>Qwik - 非常快🚤</h2><p>适合人群：</p><ul><li>如果您想要一个高性能的Web应用</li><li>现有的React开发人员，希望尝试一种高性能且学习曲线平缓的框架</li></ul><p>最后一个但同样重要的框架是Qwik。<strong>Qwik是另一个利用JSX和函数组件的框架，类似于Solid.js，为基于React的开发人员提供了一个熟悉的环境，以便尽快上手。正如其名字所表达的，Qwik的主要目标是实现您应用程序的最高性能和最快执行速度。</strong></p><p>Qwik通过利用可恢复性（resumability）的概念来实现其速度。简而言之，可恢复性基于在服务器上暂停执行并在客户端上恢复执行而无需重新播放和下载全部应用程序逻辑的想法。这是通过延迟JavaScript代码的执行和下载来实现的，除非有必要处理用户交互，这是一件非常棒的事情。它使整体速度提高，并将带宽降低到绝对最小值，从而实现近乎瞬间的加载。</p><h2>结论</h2><p>在我们所提及的所有框架和库中，最大的共同点是它们的熟悉度。每个框架和库都试图以构建在当前知识基础上的方式吸引潜在的新开发者，而不是做一些全新的事情，这是一个非常棒的理念。</p><p>当然，还有许多我们未在整篇文章中提及但值得一提的库和框架。例如，Angular 除了新的标志和文档外，还包括信号和新的控制流。还有 Remix，它增加了对 Vite、React Server Components 和新的 Remix SPA 模式的支持。最后，我们不能忘记 Next.js，它在过去几年中已成为 React 开发者的默认选择，为新的 React 功能铺平了道路。<br></p><p>作者：腾讯TNTWeb前端团队<br>链接：https://juejin.cn/post/7339830464000213027<br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><br></p><p><br></p><p><br></p><p><br></p><ul><li></li></ul><p><br></p>",
    "id": 95379130157204,
    "lookNum": 8863
  },
  {
    "title": "2024 Vue 生态工具推荐",
    "label": [
      "VUE",
      "UNIAPP",
      "HTML5",
      "CSS"
    ],
    "time": "2024-03-18 03:24:10",
    "uptime": "2024-03-18 03:24:10",
    "creator": "风中追风",
    "type": "rencetly",
    "abstract": "在没有任何遗留限制的情况下从零启动一个项目可能会令人鸡冻，但也会令人头大。不受限制地自由构建 App 可能会导致浪费大量时间研究和评估工具，最终会分散实际工作的注意力。即使做出了最好的选择，也总会重新考虑备胎方案，这就是“选择的悖论”。",
    "logo": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa0bccb0c1204814a881af86305442d0~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1920&h=1080&s=97854&e=jpg&b=408a6f",
    "content": "<p><br></p><p>本期共享的是 —— Vue 生态系统中的所有行业标准工具。</p><h2>包管理器</h2><p>处理外部包的人气工具有 3 种：</p><ul><li><code>npm</code></li><li><code>yarn</code></li><li><code>pnpm</code></li></ul><p><code>npm</code> 又老又慢。<code>yarn</code> 速度更快，是一个可靠的选择。但总体而言，<code>pnpm</code> 天下第一，它速度极快且节省空间。<code>pnpm</code> 在许多地方使用每段代码，而不需要额外的副本。此外，<code>pnpm</code> 本身支持具有最少配置的 monorepo 设置。</p><p>个人建议：包管理器优先选择 <code>pnpm</code></p><h2>构建工具</h2><p>在这里推荐 Vite 应该不足为奇。Vite 使用原生 ES 模块，实现快如闪电的服务器启动。Vite 具有内置的热模块替换支持，而且还通过 Rollup 优化生产构建，确保既小又快的加载打包。此外，与其他备胎方案相比，Vite 配置要容易得多。最后，Vite 因为与框架无关而获得加分。</p><p>个人推荐：构建工具优先选择 <code>Vite</code></p><h2>Vue 版本</h2><p>Vue 2 文档在搜索引擎和 Stackoverflow 中的排名仍然高举不下，如果我们必须在版本之间进行选择，这可能会令人头大。但粉丝请记住，Vue 2 不再开源维护，Vue 3 现在是长期支持的版本。Vue 3 具有先前版本的所有优点，但具有利用组合式 API 的不同语法。</p><p>个人建议：Vue 版本优先选择 Vue 3</p><h2>SFC（单文件组件）</h2><p>将组件的所有构建块保留在同一个位置是 Vue 的一大特色，SFC = 模板 + 样式 + 脚本。如果您认为某个组件变得又臭又长，那么最好将其拆分为子组件。我们仍然可以为每个部分使用不同的文件，但请不要这样做。</p><p>个人建议：优先选用 SFC</p><h2>路由</h2><p>Vue 有一个官方的路由模块，它与 Vue 内核深度集成，这使构建 SPA（单页应用程序）变得轻而易举。</p><p>一些给力的功能包括嵌套和动态路由、基于模块化组件的配置、路由参数、过渡效果、与自动活动 CSS 类的链接、HTML5 <code>history</code> 模式或哈希模式，以及可自定义的滚动行为。</p><p>由于缺乏替代品，Vue Router 无法获得应有的宣传和荣誉，但它确实是一个极其强大且功能齐全的库。</p><p>个人建议：优先选用 Vue Router</p><h2>状态管理</h2><p>这可能有点令人头大，因为在 Pinia 取代 Vuex 之前，Vuex 多年来一直是官方推荐。Pinia 是从零开始编写的，与 Vue 3 的组合式 API 架构无缝集成。Pinia 现在是状态管理的官方推荐。</p><p>Pinia 的唯一真正替代方案是使用自定义组合式函数来保存我们的状态。对于迷你 App 而言，这可能是一个不错的解决方案，但由于 Pinia 遵循相同的架构，具有很小的占用空间、增强的性能和开发工具支持，因此被强烈推荐。</p><p>个人建议：优先使用 Pinia</p><h2>数据请求</h2><p>原生 <code>fetch</code> 已经获得了重要的浏览器支持，这被认为是人气爆棚的 axios 库的替代品。VueUse 还提供了带有更高级配置选项的 <code>useFetch</code> 钩子。</p><p>但我强烈推荐的是 <code>vue-query</code>。它使用声明性语法简化了数据请求，并优雅地处理一大坨重复性任务，比如加载和错误状态、分页、过滤、排序和缓存。</p><p>个人建议：数据请求优先选择 Vue Query</p><h2>组件营销</h2><p>我确信还有其他选择，但 Storybook 占据主导地位，以至于其他所有选项都不在本人的考虑范围内。真正的问题是 Storybook 是否值得大肆宣传。</p><p>就我个人而言，我确实喜欢使用它来单独开发组件。Storybook 速度更快，让我了解组件的每个依赖。此外，它可以是一种很好的文档形式。</p><p>个人建议：组件文档优先选择 Storybook</p><h2>测试</h2><p>测试问题本身就可以写成一篇文章。我将重点关注我认为对任何 App 单元测试、e2e（端到端测试）和可视化测试都至关重要的测试类型。</p><h3>单元测试</h3><p>到目前为止，所有建议均来自我的个人经验。所以 Jest 就是我在本节中应该推荐的内容。它是一款既给力又可靠的测试运行器，我对它非常满意。</p><p>但有一个工具我还没有机会测试。Vitest 是一个由 Vite 驱动的测试运行器，具有兼容 Jest 的语法，我认识的每个人都支持它。所以我必须选择它作为推荐。</p><p>个人建议：单元测试优先选择 Vitest</p><h3>端到端测试</h3><p>使用 Cypress，它不仅是人气最高的选项，而且最新版本在稳定性和消除不稳定方面投入了大量精力。除了成为对开发者最友好的工具之外，它还使其成为 e2e 测试的最佳选择。</p><p>另一种选择是 Playwright，总体上可能会更快一些，但对我来说，采用率和生态系统还不够大，不足以在我的管道中得到信任。</p><p>个人建议：端到端测试优先选择 Cypress</p><h3>可视化测试</h3><p>这个难以抉择。我目前正在使用 Applitools，并且我非常了解良好的可视化测试套件的重要性。虽然但是，多用户环境中的冲突解决是极其痛苦的，并且绝对可以改进。</p><p>我的建议肯定是拥​​有一个可视化测试套件，我保证当我的工作流程不再让我头大时，我会带着一个特定的工具回来。</p><p>个人建议：你开心就好</p><h2>UI 框架</h2><p>我甚至不记得我最后一次使用 UI 框架的愉快经历。而且可能它并不在 Vue 世界中。选择很多，但问题也很多。配置地狱、臃肿的实现、糟糕的性能和内存泄漏等等。这就是为什么我当前建议在无头组件库之上进行自定义实现。在 Vue 世界中，这意味着 shadcn-vue 构建在 radix-vue 之上。这不是一个我们可以立即安装并开始使用的库。我们需要努力使其适应我们的风格指南，对我来说，这是一件好事。</p><p>根据记录，如果您想要开箱即用的 UI 库，若干人气爆棚的选项包括但不限于：</p><ul><li>Vuetify</li><li>Element UI</li><li>Quasar Framework</li></ul><p>个人建议：UI 框架优先选择 shadcn-vue 和 radix-vue</p><h2>静态类型</h2><p>毋庸置疑，这个话题的争议性比超乎我的想象。我知道 TS 很容易被滥用，并剥夺编程的乐趣，但私以为如果 TS 使用得当，它可以增强我们作为程序员阅读代码的主要角色。强烈推荐批判性思维和 TSLint。</p><p>个人建议：静态类型优先选择 TS</p><h2>IDE（集成开发环境）</h2><p>有两个人气爆棚且平分秋色的选择：IntelliJ 和 VSCode。IntelliJ 不是免费的，但 Vue 是开箱即用的支持，而 VSCode 是免费且开源的，但需要额外的配置。如果您更喜欢 VSCode，请确保安装 Volar 和 TypeScript Vue Plugin（Volar），增强开发体验。</p><p>个人建议：IDE 优先选择 IntelliJ 或 VSCode</p><h2>API文档</h2><p>Swagger 是迄今为止人气最高的选择。它基于 OpenAPI 规范，可以轻松地与其他开发者共享 API 文档。这是一个成熟且得到良好支持的项目，背后有一个庞大的社区。</p><p>个人建议：API 文档优先选择 Swagger</p><h2>结语</h2><p>这些都是我在 2024 年使用 Vue 构建可扩展 App 的个人建议。机智如你可能已经察觉，大部分情况下我都喜欢坚持行业标准。私以为这可以与其他工具产生协同作用，并且它们的热度使得在 StackOverflow 上寻找错误变得更容易。举个栗子，偏离标准，比如实现自己的轻量级路由，一开始似乎是个好主意，但从长远来看，它肯定会导致比解决的问题更多的问题。</p><p>本期话题是 —— 你有什么小众但好用的 Vue 工具人推荐吗？</p><p>欢迎在本文下方自由言论，文明共享。谢谢大家的点赞，掰掰~</p><p><strong>《前端猫猫教》每日 9 点半更新，坚持阅读，自律打卡，每天一次，进步一点</strong></p>",
    "id": 7830128514090,
    "lookNum": 3174
  },
  {
    "title": "🔥 2024 推荐一款 Vue3 移动端模板 （⚠十个理由）",
    "label": [
      "VUE"
    ],
    "time": "2024-03-18 03:31:27",
    "uptime": "2024-03-18 03:31:27",
    "creator": "风中追风",
    "type": "rencetly",
    "abstract": "我之前写过一篇 推荐一款基于Vue3的移动H5模板，加速你的移动应用开发，那篇文章介绍了我为什么做这个模板，简单讲当时 Vite 作为一款新的构建工具刚刚出来，还有Vue3也刚刚发布不久，社区里面关于中后台模板非常丰富，但是移动端的还很少，或者说做的不够好，所以那样一个契机下我从2022年一直开源到现在，也快两年时间了。 这个过程中，vue3-vant-mobile 也发布了 2.0 版本。新增了很多功能和示例，这是这篇文章的目的之一，讲讲新增了什么。第二个目的，2024年的时候，移动端模板也有很多了，不过我自认为我做的还算是可以的，所以我想推荐你用这一款。 需要强调的是移动端该有的东西，本文没有太多描述，它本该如此。介绍的是相对于其它模板的优势。希望的是收获更多关注，让模板有更多人使用。为了不让文章那么乏味，会有对比、会有思考，我们开始吧",
    "logo": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be6096222ba841e79c456cfb75d12ce8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=878&h=636&s=34474&e=png&b=ffffff",
    "content": "<h3>1. vue3生态 - 最好用的 DX 体验都有</h3><p>在模板早期的时候，它支持的事情不是很多，就是一个很普通的移动端模板，应该有的特性比如：移动端适配、Mock 数据模拟、VConsole 调试、Less 预处理器，默认内置的组件库，以及 vue3 全家桶里面的状态管理 Pinia、Router、setup、TS 支持等等。不过在 2.0 的时候，我增加了基于文件路由、组件自动引入、基于文件路由的布局系统、API自动导入、PWA（渐进式Web）、Unocss、PC 版心等等。这些新特性在使用 VS Code 编辑器进行业务开发，就会发现效率飞起。对了，Eslint 采用了antfu 的最新 eslint flat 插件配置，DX 体验更上一层楼。在同类项目当中，我发现这些特性要么就是没有集成、或者不全、甚至依赖版本滞后，但是这个模板一直在更新，使用最新最稳定的版本。</p><h3>2. vw 响应式、PC友好</h3><p>很多做前端的同学都知道，移动端适配这块有两种主流的方案，rem 和 vw, 不过基于 rem 的方案也说过是应对早期这种适配的解决方案，现在 vw 单位在众多浏览器支持度更好了，更建议使用 vw, 所以模板也是采用了这种实现。PC 友好又是什么呢？vw/vh 是一种视宽和视高的单位，基于浏览器窗体大小来的；而 rem 是基于文档头设置的font-size 决定的, 当用户在 PC 端打开你的移动端应用的时候，所有页面元素都会放大，导致很多交互都失效了，甚至个别元素不能操作。如果 rem 方案的话，我之前写过一款 rem-font-size 插件，可以设置一个版心，其实就是修改根字体大小，以及限制最大宽度，vw/vh适配 要多谢 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwswmsword%2Fpostcss-mobile-forever\" target=\"_blank\">postcss-mobile-forever</a> &nbsp;插件的作者给模板的一个PR，它也解决了 PC 版心的问题。所以这块的担心，也帮大家考虑到了。</p><h3>3. 贡献者最多</h3><p>项目是托管在 GITHUB 上的，目前为止，有10位小伙伴参与了贡献，其中一位在我合并代码时不小心给合并掉了，当时因为这件事很难受。其实这个项目的 Fork 有 118，不过真正参与的同学也就是10位，但是也是一个很不错的数字。今天刷到尤大的一个帖子。</p><p><br></p><p>然后底下有个评论很有意思。</p><p><br></p><p>是的，在项目的早期很小的时候，项目维护者是很希望有更多贡献者参与进来，哪怕是错别字一类的PR 提交，这是很令人兴奋的事情。同时，这也意味着更多人在使用，社区影响力也就越大。</p><p>下面是给 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FCharleeWa%2Fvue3-vant-mobile%3Ftab%3Dreadme-ov-file%23contributors\" target=\"_blank\">vue3-vant-mobile</a> 贡献的小伙伴，谢谢他们 。</p><p><br></p><h3>4. ESM 默认</h3><p>估计不少同学会笑起来，ESM 默认就是在package.json 设置 type: \"module\"？ 这也是一个优势吗？至少我认为是的， 从两方面说说。其中一方面是如果不设置项目类型，项目默认采用Commonjs 规范，在一个没有明确类型的项目里，可能存在两种 CJS 或者 ESM 写法，让当事人去维护感觉会很错乱。当我显式设置 ESM 项目类型以后，1.0 以前很多的模块引入写法以及包依赖就报了大量错误，所以升级到 2.0 是一大部分工作，相当于重写。另外一方面，可能使用的人无感知，就是本机会加快渲染，因为采用的是浏览器原生支持的模块加载机制更快了。所以这也算是一个优势！</p><h3>5. Vant 官方社区推荐</h3><p>模板内置了 Vant 组件库，我自认为这是移动端最好的组件库之一。有一天，我在看 Vant 官网文档的时候，突然发现我的这个模板项目被 Vant、Rspack 作者设置为了官网的生态之一，这一点很让我兴奋。好奇什么时候被添加进去的，所以我翻看了 commit 提交记录。</p><p><br></p><p>这是官网的 - <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fvant-ui.github.io%2Fvant%2F%23%2Fzh-CN%23she-qu-sheng-tai\" target=\"_blank\">补充</a>。</p><p><br></p><p>如果说他们愿意把这个项目放到他们官网生态里面，至少说明它还不错，可以给大家一个很好的示范。这好比一个非常有公信力的人给你一个人格背书，所以大家可以放心使用。</p><h3>6. 不断增加的演示和示例</h3><p>自 2.0 以后，项目增加了 unocss 示例、持久化 Pinia 演示、404页演示、重写了 Dark Mode，未来还会增加更多组件，以及高级组件。</p><p>刚截图的时候，发现9分钟前的时候有人提需求，哈哈哈哈！（谁给项目提一个PR 🎉 ~ ）</p><p>这是已经完成的工作，作者很认真做开源。</p><h3>7. TS纯度 63+</h3><p>TS 语言的好处是不言而喻的，不只是提前发现类型错误问题，还有类型推导这种方便的特性。我之前为了快速完成一个 demo 没有使用 ts, 我突然意识到我都快不会写 js 项目了 😓。总之，真的很香！如果模板示例增多的话，Vue 语言应该会占更大部分，目前 TS 多，是因为不少配置文件。</p><h3>8. 星星 570+</h3><p>我以前的想法 100+ 就很满足了，但是后来就像滚雪球一样，大家都在用的时候，你发现你要做的更好。继续加油！<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FCharleeWa%2Fvue3-vant-mobile\" target=\"_blank\">给我鼓励 ⭐</a> 。</p><h3>9. 代码性能评分100%</h3><p>最近，我使用 lighthourse 工具分析了这个模板，把所有细节重新优化了一下，大家可以看到跑分还是不错的。</p><h3>10. 大佬关注</h3><p>有 Vant 、Rspack 作者，还有大圣老师，他们都在关注。</p><p><br></p>",
    "id": 31229246375886,
    "lookNum": 6171
  },
  {
    "title": "一个 url 就把人家网站克隆了？",
    "label": [
      "HTML5",
      "CSS",
      "JAVASCRIPT",
      "VUE"
    ],
    "time": "2024-03-18 03:32:55",
    "uptime": "2024-03-18 03:32:55",
    "creator": "风中追风",
    "type": "rencetly",
    "abstract": "今天瞧见了一个开源库，https://github.com/abi/screenshot-to-code ，根据它的描述，这个简单的应用程序可以将屏幕截图转换为代码（HTML/Tailwind CSS、React、Bootstrap 或 Vue）。 它使用 GPT-4 Vision 生成代码，并使用 DALL-E 3 生成外观相似的图像。 更加逆天的是，现在是你只要输入一个 URL，他就给你把人家网站克隆了。   ",
    "logo": "https://pics5.baidu.com/feed/3b87e950352ac65c9824b4a2e2d96a1792138af4.jpeg?token=320379ca52e8e6acadc28c512a763eba",
    "content": "<p><br></p><h3>这技术背后的实现原理是什么</h3><p>screenshot-to-code这个工具，其核心功能是将图像转化为代码。它基于开放人工智能库GPT-4 Vision和DALL-E 3的技术，这两种AI模型都是OpenAI的产品且在视觉理解方面表现出色。</p><p>当用户上传截图，GPT-4 Vision会读取并理解截图中的内容，然后基于这些理解生成对应的HTML，Tailwind，React，Vue等代码。这部分对应的源码可以在这里查看 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fabi%2Fscreenshot-to-code%2Fblob%2F072b286b6dfa65eaa646f68def8a0b0f6d157217%2Fbackend%2Froutes%2Fgenerate_code.py%23L43\" target=\"_blank\"><strong>https://github.com/abi/screenshot-to-code/blob/072b286b6dfa65eaa646f68def8a0b0f6d157217/backend/routes/generate_code.py#L43</strong></a> ，背后推动的 prompt 可以简单了解下</p><pre><code class=\"language-hljs language-xml code-block-extension-codeshownum\">HTML_TAILWIND_SYSTEM_PROMPT = \"\"\"\nYou are an expert Tailwind developer\nYou take screenshots of a reference web page from the user, and then build single page apps \nusing Tailwind, HTML and JS.\nYou might also be given a screenshot(The second image) of a web page that you have already built, and asked to\nupdate it to look more like the reference image(The first image).\n\n- Make sure the app looks exactly like the screenshot.\n- Pay close attention to background color, text color, font size, font family, \npadding, margin, border, etc. Match the colors and sizes exactly.\n- Use the exact text from the screenshot.\n- Do not add comments in the code such as \"&lt;!-- Add other navigation links as needed --&gt;\" and \"&lt;!-- ... other news items ... --&gt;\" in place of writing the full code. WRITE THE FULL CODE.\n- Repeat elements as needed to match the screenshot. For example, if there are 15 items, the code should have 15 items. DO NOT LEAVE comments like \"&lt;!-- Repeat for each news item --&gt;\" or bad things will happen.\n- For images, use placeholder images from https://placehold.co and include a detailed description of the image in the alt text so that an image generation AI can generate the image later.\n\nIn terms of libraries,\n\n- Use this script to include Tailwind: &lt;script src=\"https://cdn.tailwindcss.com\"&gt;&lt;/script&gt;\n- You can use Google Fonts\n- Font Awesome for icons: &lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css\"&gt;&lt;/link&gt;\n\nReturn only the full code in &lt;html&gt;&lt;/html&gt; tags.\nDo not include markdown \"```\" or \"```html\" at the start or end.\n\"\"\"\n</code></pre><p>前面介绍过，他不只是可以生成 HTML 的代码，还可以囊括其他语言，包括 react 和 Vue。其中有一个我不太理解的地方，if there are 15 items, the code should have 15 items 那如果这里有 100 个 list 的 item，他是否生成 100 个呢，为什么不告诉模型，使用 list.map(e⇒componet)的方式呢？将统一的模式封装成一个独立的组件，代码的维护性不是大大的加强吗？</p><h3>生成代码的维护性如何？</h3><p>带着疑问，跑了一下demo，果不其然，生成的代码确实是比较机械化的方式，还是缺乏维护性的。</p><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4513e98ea96148a680bec06e88efde0a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2000&h=1109&s=126580&e=webp&b=042347\" alt=\"loading\" data-href=\"\" style=\"\"/></p><h3>为何需要 DALLE3</h3><p>而DALL-E 3则负责生成与原图相似的图像，这能帮助用户更直观地预览和了解生成的代码对应的页面效果。</p><p>screenshot-to-code的优势在于，它不仅可以从图片生成代码，还可以根据代码进一步优化图片，这种“图片至代码，代码至图片”的双向优化，使结果更精细，更贴近用户需求。</p><p>然而给我的感觉是，这种生成的代码更像是一种一锤子买卖的外包工程，基本不具备维护性的。</p><h3>其他生成代码的工具</h3><p>据我了解，vercel 很早就在做代码自动生成，而且很早就推出了其服务，服务在此：<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fv0.dev%2F\" target=\"_blank\"><strong>https://v0.dev/</strong></a></p><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dd94043798144e0aafb385a8cf11bc7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2000&h=621&s=15212&e=webp&b=fdfdfd\" alt=\"loading\" data-href=\"\" style=\"\"/></p><p>使用的方式就是和模型对话来生成代码，代码是 vercel 提供的服务，实时渲染给你看效果，而且，还可以基于效果继续进行对话，目前我没有触发到最大的对话条数，理论上可以一直对话。如下就是我生成的效果。从美观度上来看，还是挺不错的。</p><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01359dd8fb7147acb6b1f69cc6f9f086~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2000&h=1370&s=33324&e=webp&b=ffffff\" alt=\"loading\" data-href=\"\" style=\"\"/></p><p>其自动生成的代码如下：</p><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62d59b31e2c04ef7ad743d66a9df9121~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2000&h=1282&s=87356&e=webp&b=00060b\" alt=\"loading\" data-href=\"\" style=\"\"/></p><p>同样的弊端，也在 vercel 这套自动生成代码上有所体现：</p><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdd1a2b2be584a04a28742e0a36d53fc~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2000&h=824&s=73664&e=webp&b=fdfdfd\" alt=\"loading\" data-href=\"\" style=\"\"/></p><p>我看了一个生成有列表相关的例子，这里通过浏览代码发现，他这里依旧是机械化的翻译了 dom 结构，而不是使用可维护性较高的方式来输出。</p><p>总结：个人感觉，这块目前用来做一些demo，或者做一些打一些底稿，还是很有助于效率提高的。对于screenshot-to-code不要认为他能够直接可以将别人web 给直接复刻了，然后就轻松拿来运营，至少离这里还差太远太远的距离了，如后端逻辑呢？网站的性能呢？目前基本上等同于对于 HTML 点击右键，保存网页。对于 vercel 的服务，可以用来做开发提效，让它生成一些代码，然后从中获取一些灵感或者手动提取可复用组件。</p><p><strong>探索代码的无限可能，与老码小张一起开启技术之旅。点关注，未来已来，每一步深入都不孤单。<br></strong></p><p><br></p><p><br></p>",
    "id": 83644761055536,
    "lookNum": 8904
  }
]