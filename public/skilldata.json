[{"title":"HTML5","subTitle":"超文本标记语言用于创建网页的标准标记语言","label":[],"time":"2024-04-14 03:18:53","uptime":"2024-06-08 14:26:54","creator":"风中追风","type":"tech","abstract":"您可以使用 HTML 来建立自己的 WEB 站点，HTML 运行在浏览器上，由浏览器来解析","logo":"https://img0.baidu.com/it/u=2729549399,1815700033&fm=253&fmt=auto&app=138&f=JPEG?w=507&h=507","content":"<h2 style=\"text-align: start;\"><a href=\"#new\" name=\"new\"=\"\">HTML5新标签</a></h2><table style=\"width: auto; text-align: start;\"><tbody><tr><th colspan=\"1\" rowspan=\"1\" width=\"110\" style=\"text-align: left;\">标签</th><th colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: left;\">描述</th></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;audio&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义音频内容</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;video&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义视频（video 或者 movie）</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;source&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义多媒体资源 &lt;video&gt; 和 &lt;audio&gt;</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;embed&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义嵌入的内容，比如插件。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;track&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">为诸如 &lt;video&gt; 和 &lt;audio&gt; 元素之类的媒介规定外部文本轨道。</td></tr></tbody></table><table style=\"width: auto; text-align: start;\"><tbody><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;article&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义页面独立的内容区域。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;aside&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义页面的侧边栏内容。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;bdi&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">允许您设置一段文本，使其脱离其父元素的文本方向设置。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;command&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义命令按钮，比如单选按钮、复选框或按钮</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;details&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">用于描述文档或文档某个部分的细节</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;dialog&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义对话框，比如提示框</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;summary&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">标签包含 details 元素的标题</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;figure&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">规定独立的流内容（图像、图表、照片、代码等等）。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;figcaption&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义 &lt;figure&gt; 元素的标题</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;footer&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义 section 或 document 的页脚。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;header&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义了文档的头部区域</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;mark&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义带有记号的文本。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;meter&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义度量衡。仅用于已知最大和最小值的度量。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;nav&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义导航链接的部分。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;progress&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义任何类型的任务的进度。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;ruby&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义 ruby 注释（中文注音或字符）。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;rt&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义字符（中文注音或字符）的解释或发音。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;rp&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;section&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义文档中的节（section、区段）。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;time&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义日期或时间。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;wbr&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">规定在文本中的何处适合添加换行符。</td></tr></tbody></table><h2 style=\"text-align: start;\"><a href=\"#storage\" name=\"storage\"=\"\">WEB本地存储</a></h2><p style=\"text-align: start;\">使用HTML5可以在本地存储用户的浏览数据。</p><p style=\"text-align: start;\">早些时候,本地存储使用的是 cookie。但是Web 存储需要更加的安全与快速. 这些数据不会被保存在服务器上，但是这些数据只用于用户请求网站数据上.它也可以存储大量的数据，而不影响网站的性能.</p><p style=\"text-align: start;\">数据以 键/值 对存在, web网页的数据只允许该网页访问使用。</p><h3 style=\"text-align: start;\">localStorage 和 sessionStorage </h3><p style=\"text-align: start;\">客户端存储数据的两个对象为：</p><ul><li style=\"text-align: start;\">localStorage - 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。</li><li style=\"text-align: start;\">sessionStorage - 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。</li></ul><p style=\"text-align: start;\">不管是 localStorage，还是 sessionStorage，可使用的API都相同，常用的有如下几个（以localStorage为例）：</p><ul><li style=\"text-align: start;\">保存数据：localStorage.setItem(key,value);</li><li style=\"text-align: start;\">读取数据：localStorage.getItem(key);</li><li style=\"text-align: start;\">删除单个数据：localStorage.removeItem(key);</li><li style=\"text-align: start;\">删除所有数据：localStorage.clear();</li><li style=\"text-align: start;\">得到某个索引的key：localStorage.key(index);</li></ul><h2 style=\"text-align: start;\"><a href=\"#worker\" name=\"worker\"=\"\">WEB WORKER</a></h2><p style=\"text-align: start;\">web worker 是运行在后台的 JavaScript，不会影响页面的性能。</p><h3 style=\"text-align: start;\">什么是 Web Worker？</h3><p style=\"text-align: start;\">当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。</p><p style=\"text-align: start;\">web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</p><pre><code >\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt; \n&lt;meta charset=\"utf-8\"&gt; \n&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; \n&lt;/head&gt;\n&lt;body&gt;\n \n&lt;p&gt;计数： &lt;output id=\"result\"&gt;&lt;/output&gt;&lt;/p&gt;\n&lt;button onclick=\"startWorker()\"&gt;开始工作&lt;/button&gt; \n&lt;button onclick=\"stopWorker()\"&gt;停止工作&lt;/button&gt;\n \n&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; Internet Explorer 9 及更早 IE 版本浏览器不支持 Web Workers.&lt;/p&gt;\n \n&lt;script&gt;\nvar w;\n \nfunction startWorker() {\n    if(typeof(Worker) !== \"undefined\") {\n        if(typeof(w) == \"undefined\") {\n            w = new Worker(\"demo_workers.js\");\n        }\n        w.onmessage = function(event) {\n            document.getElementById(\"result\").innerHTML = event.data;\n        };\n    } else {\n        document.getElementById(\"result\").innerHTML = \"抱歉，你的浏览器不支持 Web Workers...\";\n    }\n}\n \nfunction stopWorker() \n{ \n    w.terminate();\n    w = undefined;\n}\n&lt;/script&gt;\n \n&lt;/body&gt;\n&lt;/html&gt;</code></pre><h2 style=\"text-align: start;\"><a href=\"#websocket\" name=\"websocket\"=\"\">WEBSOCKET</a></h2><p style=\"text-align: start;\">WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p><p style=\"text-align: start;\">WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><p style=\"text-align: start;\">在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p><p style=\"text-align: start;\">现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。</p><p style=\"text-align: start;\">HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。</p><pre style=\"text-align: start;\"><code>var Socket = new WebSocket(url, [protocol] );</code></pre><h3 style=\"text-align: start;\">WebSocket 事件</h3><p style=\"text-align: start;\">以下是 WebSocket 对象的相关事件。假定我们使用了以上代码创建了 Socket 对象：</p><table style=\"width: auto; text-align: start;\"><tbody><tr><th colspan=\"1\" rowspan=\"1\" width=\"10%\" style=\"text-align: left;\">事件</th><th colspan=\"1\" rowspan=\"1\" width=\"25%\" style=\"text-align: left;\">事件处理程序</th><th colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: left;\">描述</th></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">open</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">Socket.onopen</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">连接建立时触发</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">message</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">Socket.onmessage</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">客户端接收服务端数据时触发</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">error</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">Socket.onerror</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">通信发生错误时触发</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">close</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">Socket.onclose</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">连接关闭时触发</td></tr></tbody></table><h3 style=\"text-align: start;\">WebSocket 方法</h3><p style=\"text-align: start;\">以下是 WebSocket 对象的相关方法。假定我们使用了以上代码创建了 Socket 对象：</p><table style=\"width: auto; text-align: start;\"><tbody><tr><th colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: left;\">方法</th><th colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: left;\">描述</th></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">Socket.send()</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">使用连接发送数据</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">Socket.close()</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">关闭连接</td></tr></tbody></table><h2 style=\"text-align: start;\"><a href=\"#canvas\" name=\"canvas\"=\"\">CANVAS</a></h2><p style=\"text-align: start;\">Canvas是HTML5提供的一个绘图API，它允许通过JavaScript在网页上动态绘制图形、图像以及进行图形处理。<br></p><p style=\"text-align: left;\">使用<span style=\"color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); font-size: 14px;\"><code>&lt;canvas&gt;</code></span>标签即可创建一个Canvas元素，例如：</p><pre style=\"text-align: left;\"><code>&lt;canvas id=\"myCanvas\" width=\"500\" height=\"300\"&gt;&lt;/canvas&gt;\n</code></pre><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"><strong>如何在Canvas上绘制一条直线？<br></strong></span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">可以使用Canvas的</span>getContext()<span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">方法获取绘图上下文，然后</span><a href=\"https://so.csdn.net/so/search?q=%E4%BD%BF%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87&amp;spm=1001.2101.3001.7020\" target=\"_blank\" style=\"text-align: left;\">使用上下文</a><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">对象的方法绘制直线，例如：</span></p><pre><code >var canvas = document.getElementById('myCanvas');\nvar ctx = canvas.getContext('2d');\n\nctx.beginPath();\nctx.moveTo(50, 50);  //开始\nctx.lineTo(200, 200); //结束\nctx.stroke();\n```</code></pre><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"><strong>如何在Canvas上绘制一个矩形？<br></strong></span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">使用Canvas的上下文对象的方法</span><a href=\"https://so.csdn.net/so/search?q=%E7%BB%98%E5%88%B6%E7%9F%A9%E5%BD%A2&amp;spm=1001.2101.3001.7020\" target=\"_blank\" style=\"text-align: left;\">绘制矩形</a><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">，例如：</span></p><pre><code >var canvas = document.getElementById('myCanvas');\nvar ctx = canvas.getContext('2d');\n\nctx.fillStyle = 'red';\nctx.fillRect(50, 50, 200, 100);  // x,y,width, height\n```</code></pre><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"><strong>如何在Canvas上绘制一个圆形？<br></strong></span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">使用Canvas的上下文对象的方法绘制圆形，例如：</span></p><pre><code >var canvas = document.getElementById('myCanvas');\nvar ctx = canvas.getContext('2d');\n\nctx.beginPath();\nctx.arc(150, 150, 100, 0, 2 * Math.PI); // x,y, r, begin, stop\nctx.stroke();\n```</code></pre><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"><strong>如何在Canvas上绘制一张图片？<br></strong></span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">可以使用Canvas的上下文对象的方法绘制图片，例如：</span></p><p><br></p><pre><code >var canvas = document.getElementById('myCanvas');\nvar ctx = canvas.getContext('2d');\n\nvar image = new Image();\nimage.src = 'image.jpg';\n\nimage.onload = function() {\n  ctx.drawImage(image, 50, 50);\n}\n```</code></pre><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"><strong>如何在Canvas上实现动画效果？<br></strong></span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">可以使用JavaScript的</span>requestAnimationFrame()<span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">方法创建动画循环，在每一帧中更新Canvas上的内容，例如：</span></p><p><br></p><pre><code >var canvas = document.getElementById('myCanvas');\nvar ctx = canvas.getContext('2d');\n\nfunction animate() {\n  // 更新Canvas内容\n\n  requestAnimationFrame(animate);\n}\n\nanimate();\n```</code></pre><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"><strong>如何在Canvas上捕捉鼠标事件？<br></strong></span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">可以使用Canvas的</span>addEventListener()<span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">方法监听鼠标事件，例如：</span></p><p><br></p><pre><code >var canvas = document.getElementById('myCanvas');\nvar ctx = canvas.getContext('2d');\n\ncanvas.addEventListener('mousemove', function(event) {\n  var mouseX = event.clientX - canvas.offsetLeft;\n  var mouseY = event.clientY - canvas.offsetTop;\n\n  // 处理鼠标移动事件\n});\n```</code></pre><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"><strong>如何在Canvas上实现图形的动态交互？<br></strong></span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">可以使用鼠标事件、键盘事件等与Canvas交互的事件，根据事件触发时的坐标或按键信息更新Canvas上的内容，例如：</span></p><p><br></p><pre><code >var canvas = document.getElementById('myCanvas');\nvar ctx = canvas.getContext('2d');\n\ncanvas.addEventListener('click', function(event) {\n  var mouseX = event.clientX - canvas.offsetLeft;\n  var mouseY = event.clientY - canvas.offsetTop;\n\n  // 处理鼠标点击事件\n});\n```</code></pre><p><span style=\"color: rgb(166, 38, 164);\">var</span> dataURL = canvas.<span style=\"color: rgb(64, 120, 242);\">toDataURL</span>();可将canvas内容保存为图片</p><p><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\"><strong>如何使用Canvas进行图像处理？<br></strong></span><span style=\"color: rgb(77, 77, 77); background-color: rgb(255, 255, 255); font-size: 16px;\">可以使用Canvas的上下文对象的方法操作图像数据，例如修改像素值、应用滤镜等，从而实现图像处理效果，例如：</span></p><p><br></p><pre><code >var canvas = document.getElementById('myCanvas');\nvar ctx = canvas.getContext('2d');\n\nvar image = new Image();\nimage.src = 'image.jpg';\n\nimage.onload = function() {\n  ctx.drawImage(image, 0, 0);\n}</code></pre><hr/><h2 style=\"text-align: start;\"><a href=\"#svg\" name=\"svg\"=\"_blank\">SVG</a></h2><ul><li style=\"text-align: start;\">SVG 指可伸缩矢量图形 (Scalable Vector Graphics)</li><li style=\"text-align: start;\">SVG 用于定义用于网络的基于矢量的图形</li><li style=\"text-align: start;\">SVG 使用 XML 格式定义图形</li><li style=\"text-align: start;\">SVG 图像在放大或改变尺寸的情况下其图形质量不会有损失</li></ul><p style=\"text-align: start;\"><br></p><p style=\"text-align: start;\">与其他图像格式相比（比如 JPEG 和 GIF），使用 SVG 的优势在于：</p><ul><li style=\"text-align: start;\">SVG 图像可通过文本编辑器来创建和修改</li><li style=\"text-align: start;\">SVG 图像可被搜索、索引、脚本化或压缩</li><li style=\"text-align: start;\">SVG 是可伸缩的</li><li style=\"text-align: start;\">SVG 图像可在任何的分辨率下被高质量地打印</li><li style=\"text-align: start;\">SVG 可在图像质量不下降的情况下被放大</li></ul><h2 style=\"text-align: start;\">SVG 与 Canvas两者间的区别</h2><p style=\"text-align: start;\">SVG 是一种使用 XML 描述 2D 图形的语言。</p><p style=\"text-align: start;\">Canvas 通过 JavaScript 来绘制 2D 图形。</p><p style=\"text-align: start;\">SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。</p><p style=\"text-align: start;\">在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p><p style=\"text-align: start;\">Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</p><table style=\"width: auto; text-align: start;\"><tbody><tr><th colspan=\"1\" rowspan=\"1\" width=\"50%\" style=\"text-align: left;\">Canvas</th><th colspan=\"1\" rowspan=\"1\" width=\"50%\" style=\"text-align: left;\">SVG</th></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">依赖分辨率<br>不支持事件处理器<br>弱的文本渲染能力<br>能够以 .png 或 .jpg 格式保存结果图像<br>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">不依赖分辨率<br>支持事件处理器<br>最适合带有大型渲染区域的应用程序（比如谷歌地图）<br>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）<br>不适合游戏应用</td></tr></tbody></table><h3 style=\"text-align: start;\">SVG 圆形</h3><pre><code >&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt;\n   &lt;circle cx=\"100\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"2\" fill=\"red\" /&gt;\n&lt;/svg&gt;</code></pre><h3>SVG矩形</h3><pre><code >&lt;svg width=\"100%\" height=\"100%\" version=\"1.1\"\nxmlns=\"http://www.w3.org/2000/svg\"&gt;\n&lt;rect width=\"100\" height=\"50\"\nstyle=\"fill:blue;stroke:pink;stroke-width:2;\n               fill-opacity:0.1;stroke-opacity:0.9\"/&gt;\n&lt;/svg&gt;</code></pre><p><br></p>","id":1713035933923,"lookNum":5602,"hrefList":[{"name":"new","title":"HTML5新标签"},{"name":"storage","title":"WEB本地存储"},{"name":"worker","title":"WEB WORKER"},{"name":"websocket","title":"WEBSOCKET"},{"name":"canvas","title":"CANVAS"},{"name":"svg","title":"SVG"}]},{"title":"JavaScript","subTitle":"JavaScript是Web的编程语言","label":[],"time":"2024-04-14 14:26:10","uptime":"2024-06-08 14:49:05","creator":"风中追风","type":"tech","abstract":"JavaScript 是互联网上最流行的脚本语言，广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备","logo":"https://img1.baidu.com/it/u=3914712667,2479801161&fm=253&fmt=auto&app=138&f=JPEG?w=524&h=524","content":"<h2><a href=\"#jsbzsjlx\" name=\"jsbzsjlx\"=\"\">JS中的8种数据类型及区别</a></h2><p>包括值类型(基本对象类型)和引用类型(复杂对象类型)<span style=\"color: rgb(33, 37, 41); background-color: rgb(255, 255, 255); font-size: 14px;\"><br></span></p><h3 style=\"text-align: start;\">基本值类型</h3><ol><li style=\"text-align: left;\">Number(数字)</li><li style=\"text-align: left;\">String(字符串)</li><li style=\"text-align: left;\">Symbol(符号)</li><li style=\"text-align: left;\">BigInt</li><li style=\"text-align: left;\">Boolean(布尔)</li><li style=\"text-align: left;\">null(空)</li><li style=\"text-align: left;\">undefined(未定义)在内存中占据固定大小，保存在栈内存中</li></ol><h3 style=\"text-align: left;\"><span style=\"color: rgb(33, 37, 41); background-color: rgb(255, 255, 255);\">引用复杂数据类型</span></h3><ol><li style=\"text-align: left;\">Object(对象)</li><li style=\"text-align: left;\">Function(函数)</li><li style=\"text-align: left;\">Array(数组)</li><li style=\"text-align: left;\">Date(日期)</li><li style=\"text-align: left;\">RegExp(正则表达式)</li><li style=\"text-align: left;\">Map(键控集合)</li></ol><h5 style=\"text-align: start;\">本质区别：</h5><p style=\"text-align: start;\">基本数据类型和引用数据类型它们在内存中的存储方式不同。<br>基本数据类型是直接存储在栈中的简单数据段，占据空间小，属于被频繁使用的数据。<br>引用数据类型是存储在堆内存中，占据空间大。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址，当解释器寻找引用值时，会检索其在栈中的地址，取得地址后从堆中获得实体。</p><h5 style=\"text-align: start;\">使用场景：</h5><p style=\"text-align: start;\">Symbol：使用Symbol来作为对象属性名(key) 利用该特性，把一些不需要对外操作和访问的属性使用Symbol来定义</p><p style=\"text-align: start;\">BigInt：由于在 Number 与 BigInt 之间进行转换会损失精度，因而建议仅在值可能大于2的253次方 时使用 BigInt 类型，并且不在两种类型之间进行相互转换。</p><h3 style=\"text-align: start;\">深拷贝、浅拷贝</h3><h5 style=\"text-align: start;\">区别</h5><p style=\"text-align: start;\">如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝；如果B没变，那就是深拷贝。</p><p style=\"text-align: start;\">基本数据类型保存在栈内存，引用类型保存在堆内存中。根本原因在于保存在栈内存的必须是大小固定的数据，引用类型的大小不固定，只能保存在堆内存中，但是可以把它的地址写在栈内存中以供我们访问。</p><h5 style=\"text-align: start;\">浅拷贝</h5><ol><li style=\"text-align: start;\">直接赋值</li></ol><h5 style=\"text-align: start;\">深拷贝<span style=\"color: rgb(33, 37, 41); background-color: rgb(255, 255, 255); font-size: 14px;\">对象深拷贝</span></h5><ol><li style=\"text-align: start;\">先JSON.String然后再JSON.parse回来(没法拷贝内部函数)</li><li style=\"text-align: start;\">Object.Assign(对象的属性值为基本数据类型)</li><li style=\"text-align: start;\">使用...解构(es6的展开语法只针对第一层，对多层还是浅拷贝方式)<span style=\"color: rgb(33, 37, 41); background-color: rgb(255, 255, 255); font-size: 14px;\">数组深拷贝</span></li><li style=\"text-align: start;\">for循环实现</li><li style=\"text-align: start;\">slice方法，将原数组中抽离部分出来形成一个新数组。我们只要设置为抽离全部<br>var arr2 = arr.slice(0)</li><li style=\"text-align: start;\">concat方法,它是用于连接多个数组组成一个新的数组的方法。那么，我们只要连接它自己，即可完成数组的深拷贝。<br>var arr2 = arr.concat()</li><li style=\"text-align: start;\">ES6扩展运算符实现,该方法是最简单的（es6的展开语法只针对第一层，对多层还是浅拷贝方式）<br>var arr2 = [...arr]</li></ol><p style=\"text-align: start;\">对象或数组，使用递归函数实现深拷贝</p><p style=\"text-align: left;\"><br></p><pre><code >function deepCopy(obj) {\n  let newObj = Array.isArray(obj) ? [] : {};\n\n  for (let key in obj) {\n    if (typeof obj[key] === \"object\") {\n      newObj[key] = deepCopy(obj[key]);\n    } else {\n      newObj[key] = obj[key];\n    }\n  }\n\n  return newObj;\n}\nconst obj = { a: 1, b: { c: 2 } };\nconst obj2 = deepCopy(obj);</code></pre><hr/><h2><a href=\"#sjjcfa\" name=\"sjjcfa\"=\"\">JS中的数据类型检测方案</a></h2><h3 style=\"text-align: start;\">1.typeof</h3><ul><li style=\"text-align: start;\">console.log(typeof 1); // number</li><li style=\"text-align: start;\">console.log(typeof true); // boolean</li><li style=\"text-align: start;\">console.log(typeof 'mc'); // string</li><li style=\"text-align: start;\">console.log(typeof Symbol()) // symbol</li><li style=\"text-align: start;\">console.log(typeof function(){}); // function</li><li style=\"text-align: start;\">console.log(typeof console.log()); // function</li><li style=\"text-align: start;\">console.log(typeof []); // object</li><li style=\"text-align: start;\">console.log(typeof {}); // object</li><li style=\"text-align: start;\">console.log(typeof null); // object</li><li style=\"text-align: start;\">console.log(typeof undefined); // undefined</li></ul><p style=\"text-align: start;\">优点：能够快速区分基本数据类型</p><p style=\"text-align: start;\">缺点：不能将Object、Array和Null区分，都返回object</p><h3 style=\"text-align: start;\">2.instanceof</h3><ol><li style=\"text-align: start;\">console.log(1 instanceof Number); // false</li><li style=\"text-align: start;\">console.log(true instanceof Boolean); // false</li><li style=\"text-align: start;\">console.log('str' instanceof String); // false</li><li style=\"text-align: start;\">console.log([] instanceof Array); // true</li><li style=\"text-align: start;\">console.log(function(){} instanceof Function); // true</li><li style=\"text-align: start;\">console.log({} instanceof Object); // true</li></ol><p style=\"text-align: start;\">优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象</p><p style=\"text-align: start;\">缺点：Number，Boolean，String基本数据类型不能判断</p><h3 style=\"text-align: start;\">3.Object.prototype.toString.call()</h3><h3 style=\"text-align: start;\"><span style=\"color: rgb(33, 37, 41); background-color: rgb(255, 255, 255); font-size: 14px;\">var toString = Object.prototype.toString;</span></h3><ol><li style=\"text-align: start;\">console.log(toString.call(1)); //[object Number]</li><li style=\"text-align: start;\">console.log(toString.call(true)); //[object Boolean]</li><li style=\"text-align: start;\">console.log(toString.call('mc')); //[object String]</li><li style=\"text-align: start;\">console.log(toString.call([])); //[object Array]</li><li style=\"text-align: start;\">console.log(toString.call({})); //[object Object]</li><li style=\"text-align: start;\">console.log(toString.call(function(){})); //[object Function]</li><li style=\"text-align: start;\">console.log(toString.call(undefined)); //[object Undefined]</li><li style=\"text-align: start;\">console.log(toString.call(null)); //[object Null]</li></ol><p style=\"text-align: start;\">优点：精准判断数据类型</p><p style=\"text-align: start;\">缺点：写法繁琐不容易记，推荐进行封装后使用</p><h3 style=\"text-align: start;\">instanceof 的作用</h3><ol><li style=\"text-align: start;\">用于判断一个引用类型是否属于某构造函数；</li><li style=\"text-align: start;\">还可以在继承关系中用来判断一个实例是否属于它的父类型。</li></ol><h3 style=\"text-align: start;\">instanceof 和 typeof 的区别：</h3><ol><li style=\"text-align: start;\">typeof在对值类型number、string、boolean 、null 、 undefined、 以及引用类型的function的反应是精准的；</li><li style=\"text-align: start;\">但是，对于对象{ } 、数组[ ] 、null 都会返回object</li><li style=\"text-align: start;\">为了弥补这一点，instanceof 从原型的角度，来判断某引用属于哪个构造函数，从而判定它的数据类型。</li></ol><hr/><h2 style=\"text-align: start;\"><a href=\"#varletconst\" name=\"varletconst\"=\"\">var &amp;&amp; let &amp;&amp; const的区别</a></h2><h3 style=\"text-align: start;\">ES6之前创建变量用的是var,之后创建变量用的是let/const</h3><p>三者区别</p><ul><li style=\"text-align: start;\">var定义的变量，`没有块的概念，可以跨块访问`, 不能跨函数访问。</li><li style=\"text-align: start;\">let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。</li><li style=\"text-align: start;\">const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，且不能修改。</li><li style=\"text-align: start;\">var可以`先使用，后声明`，因为存在变量提升；let必须先声明后使用。</li><li style=\"text-align: start;\">var是允许在相同作用域内`重复声明同一个变量`的，而let与const不允许这一现象。</li><li style=\"text-align: start;\">在全局上下文中，基于let声明的全局变量和全局对象GO（window）没有任何关系 ;</li><li style=\"text-align: start;\">var声明的变量会和GO有映射关系；会产生暂时性死区</li><li style=\"text-align: start;\"><span style=\"color: rgb(235, 144, 58);\">let /const/function会把当前所在的大括号(除函数之外)作为一个全新的块级上下文，应用这个机制，在开发项目的时候，遇到循环事件绑定等类似的需求，无需再自己构建闭包来存储，只要基于let的块作用特征即可解决</span></li></ul><hr/><h2 style=\"text-align: start;\"><a href=\"#zyyhzyyl\" name=\"zyyhzyyl\"=\"\">作用域和作用域链</a></h2><h5 style=\"text-align: start;\">创建函数的时候，已经声明了当前函数的作用域==&gt;`当前创建函数所处的上下文`。如果是在全局下创建的函数就是`[[scope]]:EC(G)`，函数执行的时候，形成一个全新的私有上下文`EC(FN)`，供字符串代码执行(进栈执行)</h5><h5 style=\"text-align: start;\">定义：简单来说作用域就是变量与函数的可访问范围，`由当前环境与上层环境的一系列变量对象组成</h5><p>1.全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。</p><p>2.函数作用域：在固定的代码片段才能被访问</p><p style=\"text-align: start;\"><span style=\"color: rgb(235, 144, 58);\">作用：作用域最大的用处就是`隔离变量`，不同作用域下同名变量不会有冲突。</span></p><p style=\"text-align: start;\"><span style=\"color: rgb(235, 144, 58);\">一般情况下，变量到 创建该变量 的函数的作用域中取值。但是如果在当前作用域中没有查到，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。</span></p><hr/><h2 style=\"text-align: start;\"><a href=\"#bbhh\" name=\"bbhh\"=\"\">闭包</a></h2><h3 style=\"text-align: start;\">闭包的两大作用：保存/保护</h3><h3 style=\"text-align: start;\">闭包的概念</h3><p style=\"text-align: start;\">函数执行时形成的私有上下文EC(FN)，正常情况下，代码执行完会出栈后释放;但是特殊情况下，如果当前私有上下文中的某个东西被上下文以外的事物占用了，则上下文不会出栈释放，从而形成不销毁的上下文。 函数执行函数执行过程中，会形成一个全新的私有上下文，可能会被释放，可能不会被释放，不论释放与否，他的作用是：</p><p style=\"text-align: start;\">（1）保护：划分一个独立的代码执行区域，在这个区域中有自己私有变量存储的空间，保护自己的私有变量不受外界干扰（操作自己的私有变量和外界没有关系）；</p><p style=\"text-align: start;\">（2）保存：如果当前上下文不被释放【只要上下文中的某个东西被外部占用即可】，则存储的这些私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来了；</p><p style=\"text-align: start;\">我们把函数执行形成私有上下文，来保护和保存私有变量机制称为闭包</p><p style=\"text-align: start;\">闭包是指有权访问另一个函数作用域中的变量的函数--《JavaScript高级程序设计》</p><h3 style=\"text-align: start;\">稍全面的回答</h3><p style=\"text-align: start;\">在js中变量的作用域属于函数作用域, 在函数执行完后,作用域就会被清理,内存也会随之被回收,但是由于闭包函数是建立在函数内部的子函数, 由于其可访问上级作用域,即使上级函数执行完, 作用域也不会随之销毁, 这时的子函数(也就是闭包),便拥有了访问上级作用域中变量的权限,即使上级函数执行完后作用域内的值也不会被销毁。</p><h3 style=\"text-align: start;\">闭包的特性</h3><ol><li style=\"text-align: start;\">内部函数可以访问定义他们外部函数的参数和变量。(作用域链的向上查找，把外围的作用域中的变量值存储在内存中而不是在函数调用完毕后销毁)设计私有的方法和变量，避免全局变量的污染。</li><li style=\"text-align: start;\">函数嵌套函数</li><li style=\"text-align: start;\">本质是将函数内部和外部连接起来。优点是可以读取函数内部的变量，让这些变量的值始终保存在内存中，不会在函数被调用之后自动清除</li></ol><h3 style=\"text-align: start;\">闭包形成的条件</h3><ol><li style=\"text-align: start;\">函数的嵌套</li><li style=\"text-align: start;\">内部函数引用外部函数的局部变量，延长外部函数的变量生命周期</li></ol><h3 style=\"text-align: start;\">闭包的用途</h3><ol><li style=\"text-align: start;\">模仿块级作用域</li><li style=\"text-align: start;\">保护外部函数的变量 能够访问函数定义时所在的词法作用域(阻止其被回收)</li><li style=\"text-align: start;\">封装私有化变量</li><li style=\"text-align: start;\">创建模块</li></ol><h3 style=\"text-align: start;\">闭包应用场景</h3><p>闭包的两个场景，闭包的两大作用：`保存/保护`。</p><p style=\"text-align: start;\">在开发中, 其实我们随处可见闭包的身影, 大部分前端JavaScript 代码都是“事件驱动”的,即一个事件绑定的回调方法; 发送ajax请求成功|失败的回调;setTimeout的延时回调;或者一个函数内部返回另一个匿名函数,这些都是闭包的应用。</p><p style=\"text-align: start;\"><span style=\"color: rgb(255, 77, 79);\">闭包的优点：延长局部变量的生命周期</span></p><p style=\"text-align: start;\"><span style=\"color: rgb(255, 77, 79);\">闭包的缺点：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</span></p><p style=\"text-align: start;\"><br></p><hr/><h2 style=\"text-align: start;\"><a href=\"#jsthis\" name=\"jsthis\"=\"\">JS 中 this 的情况</a></h2><ol><li style=\"text-align: start;\">普通函数调用：通过函数名()直接调用：`this`指向`全局对象window`（注意let定义的变量不是window属性，只有window.xxx定义的才是。即let a =’aaa’; this.a是undefined）</li><li style=\"text-align: start;\">构造函数调用：函数作为构造函数，用new关键字调用时：`this`指向`新new出的对象`</li><li style=\"text-align: start;\">对象函数调用：通过对象.函数名()调用的：`this`指向`这个对象`</li><li style=\"text-align: start;\">箭头函数调用：箭头函数里面没有 this ，所以`永远是上层作用域this`（上下文）</li><li style=\"text-align: start;\">apply和call调用：函数体内 this 的指向的是 call/apply 方法`第一个参数`，若为空默认是指向全局对象window。</li><li style=\"text-align: start;\">函数作为数组的一个元素，通过数组下标调用的：this指向这个数组</li><li style=\"text-align: start;\">函数作为window内置函数的回调函数调用：this指向window（如setInterval setTimeout 等）</li></ol><hr/><h2><a href=\"#callapplbind\" name=\"callapplbind\"=\"\">call/apply/bind 的区别</a></h2><h5 style=\"text-align: start;\">相同</h5><ol><li style=\"text-align: start;\">都是用来改变函数的this对象的指向的</li><li style=\"text-align: start;\">第一个参数都是this要指向的对象</li><li style=\"text-align: start;\">都可以利用后续参数传参</li></ol><h5 style=\"text-align: start;\">不同</h5><ol><li style=\"text-align: start;\">apply和call传入的参数列表形式不同,apply 接收 arguments，call接收一串参数列表</li><li style=\"text-align: start;\">bind：语法和call一模一样，区别在于立即执行还是等待执行，bind不兼容IE6~8</li><li style=\"text-align: start;\">bind 主要就是将函数绑定到某个对象，bind()会创建一个函数，返回对应函数便于稍后调用；而apply、call则是立即调用。</li></ol><p style=\"text-align: start;\"><span style=\"color: rgb(212, 56, 13);\">总结：基于Function.prototype上的 ` apply 、 call 和 bind `调用模式，这三个方法都可以显示的指定调用函数的 this 指向。`apply`接收参数的是数组，`call`接受参数列表，`` bind`方法通过传入一个对象，返回一个` this ` 绑定了传入对象的新函数。这个函数的 `this`指向除了使用`new `时会被改变，其他情况下都不会改变。若为空默认是指向全局对象window。</span></p><p style=\"text-align: start;\"><br></p><hr/><h2><a href=\"#jthsdtx\" name=\"jthsdtx\"=\"\">箭头函数的特性</a></h2><ol><li style=\"text-align: start;\">`箭头函数没有自己的this`，会捕获其所在的上下文的this值，作为自己的this值</li><li style=\"text-align: start;\">`箭头函数没有constructor`，是匿名函数，不能作为构造函数，不能通过new 调用；</li><li style=\"text-align: start;\">`没有new.target 属性`。在通过new运算符被初始化的函数或构造方法中，new.target返回一个指向构造方法或函数的引用。在普通的函数调用中，new.target 的值是undefined</li><li style=\"text-align: start;\">`箭头函数不绑定Arguments 对象`。取而代之用rest参数...解决。由于 箭头函数没有自己的this指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定this），他们的第一个参数会被忽略。（这种现象对于bind方法同样成立）</li><li style=\"text-align: start;\">箭头函数通过 call() 或 apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。</li><li style=\"text-align: start;\">箭头函数没有原型属性 Fn.prototype 值为 undefined</li><li style=\"text-align: start;\">箭头函数不能当做Generator函数,不能使用yield关键字</li></ol><hr/><h2></h2><h2 style=\"text-align: start;\"><a href=\"#yxhyxl\" name=\"yxhyxl\"=\"\">原型关系：原型 &amp;&amp; 原型链</a></h2><ol><li style=\"text-align: start;\">每个 class都有显示原型 prototype</li><li style=\"text-align: start;\">每个实例都有隐式原型 `__proto__`</li><li style=\"text-align: start;\">实例的 `__proto__` 指向对应 class 的 prototype</li><li style=\"text-align: start;\">原型</li></ol><p style=\"text-align: start;\">在 JS 中，每当定义一个对象（函数也是对象）时，对象中都会包含一些预定义的属性。其中每个`函数对象`都有一个`prototype` 属性，这个属性指向函数的`原型对象`。</p><p style=\"text-align: start;\">原型链</p><p style=\"text-align: start;\">函数的原型链对象constructor默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针__proto__,该指针是指向上一层的原型对象，而上一层的原型对象的结构依然类似。因此可以利用__proto__一直指向Object的原型对象上，而Object原型对象用Object.prototype.__ proto__ = null表示原型链顶端。如此形成了js的原型链继承。同时所有的js对象都有Object的基本防范</p><p style=\"text-align: start;\">特点</p><p style=\"text-align: start;\"><span style=\"color: rgb(255, 122, 69);\">`JavaScript`对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</span></p><hr/><h2><a href=\"#nvew\" name=\"nvew\"=\"\">new运算符的实现机制</a></h2><ol><li style=\"text-align: start;\">首先创建了一个新的`空对象`</li><li style=\"text-align: start;\">`设置原型`，将对象的原型设置为函数的`prototype`对象。</li><li style=\"text-align: start;\">让函数的`this`指向这个对象，执行构造函数的代码（为这个新对象添加属性）</li><li style=\"text-align: start;\">判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li></ol><hr/><h2><a href=\"#eventloop\" name=\"eventloop\"=\"\">EventLoop 事件循环</a></h2><p style=\"text-align: start;\">是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列。微任务队列的代表就是，</p><p style=\"text-align: start;\">`JS``Promise.then`，`MutationObserver`，宏任务的话就是`setImmediate setTimeout setInterval`</p><p style=\"text-align: start;\">JS运行的环境。一般为浏览器或者Node。 在浏览器环境中，有JS 引擎线程和渲染线程，且两个线程互斥。 Node环境中，只有JS 线程。 不同环境执行机制有差异，不同任务进入不同Event Queue队列。 当主程结束，先执行准备好微任务，然后再执行准备好的宏任务，一个轮询结束。</p><hr/><h2><a href=\"#eventlooplbrow\" name=\"eventlooplbrow\"=\"\">浏览器中的事件循环（Event Loop)</a></h2><h5 style=\"text-align: start;\">事件循环的运行机制</h5><p style=\"text-align: start;\">先会执行栈中的内容，栈中的内容执行后执行微任务，微任务清空后再执行宏任务，先取出一个宏任务，再去执行微任务，然后在取宏任务清微任务这样不停的循环。</p><h5 style=\"text-align: start;\">eventLoop 是由JS的宿主环境（浏览器）来实现的；</h5><p>事件循环可以简单的描述为以下四个步骤:</p><ol><li style=\"text-align: start;\">函数入栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空；</li><li style=\"text-align: start;\">此期间WebAPIs完成这个事件，把回调函数放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列）</li><li style=\"text-align: start;\">执行栈为空时，Event Loop把微任务队列执行清空；</li><li style=\"text-align: start;\">微任务队列清空后，进入宏任务队列，取队列的第一项任务放入Stack(栈）中执行，执行完成后，查看微任务队列是否有任务，有的话，清空微任务队列。重复4，继续从宏任务中取任务执行，执行完成之后，继续清空微任务，如此反复循环，直至清空所有的任务。</li></ol><h5 style=\"text-align: start;\">浏览器中的任务源(task)</h5><p>宏任务(macrotask)</p><p style=\"text-align: start;\">宿主环境提供的，比如浏览器</p><p style=\"text-align: start;\">ajax、setTimeout、setInterval、setTmmediate(只兼容ie)、script、requestAnimationFrame、messageChannel、UI渲染、一些浏览器api</p><p style=\"text-align: start;\">微任务(microtask)</p><p style=\"text-align: start;\">语言本身提供的，比如promise.then</p><p style=\"text-align: start;\">queueMicrotask(基于then)、mutationObserver(浏览器提供)、messageChannel 、mutationObersve</p><hr/><h2><a href=\"#settimoutpromise\" name=\"settimoutpromise\"=\"\">setTimeout、Promise、Async/Await 的区别</a></h2><h3 style=\"text-align: start;\">setTimeout</h3><p style=\"text-align: start;\">settimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行。</p><h3 style=\"text-align: start;\">Promise</h3><p style=\"text-align: left;\">Promise本身是**同步的立即执行函数**， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行。</p><p style=\"text-align: left;\">```js<br>console.log('script start')<br>let promise1 = new Promise(function (resolve) {<br>console.log('promise1')<br>resolve()<br>console.log('promise1 end')<br>}).then(function () {<br>console.log('promise2')<br>})<br>setTimeout(function(){<br>console.log('settimeout')<br>})<br>console.log('script end')<br>// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</p><h3 style=\"text-align: start;\">async/await</h3><p style=\"text-align: left;\">async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p><p style=\"text-align: left;\">```js<br>async function async1(){<br>console.log('async1 start');<br>await async2();<br>console.log('async1 end')<br>}<br>async function async2(){<br>console.log('async2')<br>}<br><br>console.log('script start');<br>async1();<br>console.log('script end')<br><br>// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</p><hr/><p><br></p>","hrefList":[{"name":"jsbzsjlx","title":"JS中的8种数据类型及区别"},{"name":"sjjcfa","title":"JS中的数据类型检测方案"},{"name":"varletconst","title":"var &amp;&amp; let &amp;&amp; const的区别"},{"name":"zyyhzyyl","title":"作用域和作用域链"},{"name":"bbhh","title":"闭包"},{"name":"jsthis","title":"JS 中 this 的情况"},{"name":"callapplbind","title":"call/apply/bind 的区别"},{"name":"jthsdtx","title":"箭头函数的特性"},{"name":"yxhyxl","title":"原型关系：原型 &amp;&amp; 原型链"},{"name":"nvew","title":"new运算符的实现机制"},{"name":"eventloop","title":"EventLoop 事件循环"},{"name":"eventlooplbrow","title":"浏览器中的事件循环（Event Loop)"},{"name":"settimoutpromise","title":"setTimeout、Promise、Async/Await 的区别"}],"id":1713075970211,"lookNum":8597},{"title":"React","subTitle":"React是Facebook的一个开源JS框架，专注的层面为View层","label":[],"time":"2024-05-04 15:17:09","uptime":"2024-05-04 15:42:33","creator":"风中追风","type":"tech","abstract":"React认为一切页面元素都可以抽象成组件","logo":"https://img1.baidu.com/it/u=2079992994,1830113805&fm=253&fmt=auto&app=138&f=PNG?w=500&h=500","content":"<h2><a href=\"#introduce\" name=\"introduce\">React介绍</a></h2><p><span style=\"color: rgb(33, 37, 41); background-color: rgb(255, 255, 255); font-size: 16px;\">React就是Facebook的一个开源JS框架，专注的层面为View层，不包括数据访问层或者那种Hash路由（不过React 有插件支持），与Angularjs，Emberjs等大而全的框架不同，React专注的中心是Component，即组件。React认为一切页面元 素都可以抽象成组件，比如一个表单，或者表单中的某一项。</span></p><p style=\"text-align: start;\">React可以作为MVVM中第二个V，也就是View，但是并不是MVVM框架。MVVM一个最显著的特征：双向绑定。React没有这个，它是单向数据绑定的。React是一个单向数据流的库，状态驱动视图。react整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流，推崇结合immutable来实现数据不可变。</p><hr/><h2 style=\"text-align: start;\"><a href=\"#hooksyqd\" name=\"hooksyqd\">Hooks的优缺点</a></h2><h3 style=\"text-align: start;\">优点</h3><ol><li style=\"text-align: start;\">代码的可读性强，在使用hooks之前比如发布/订阅自定义事件被挂载在componentDidMount生命周期中，然后需要在componentWillUnmount生命周期中将它清楚，这样就不便于开发者维护和迭代。在使用hooks之后，通过useEffect可以将componentDidMount生命周期、componentDidUpdate生命周期和componentWillUnmount生命周期聚合起来，方便代码的维护。</li><li style=\"text-align: start;\">组件层级变得更浅了，在使用hooks之前通常使用高阶组件HOC的方法来复用多个组件公共的状态，增强组建的功能，这样肯定是加大了组件渲染的开销，损失了性能。但是在hooks中可以通过自定义组件useXxx()的方法将多个组件之间的共享逻辑放在自定义hook中，就可以轻松的进行数据互通。</li><li style=\"text-align: start;\">不再需要考虑class组件中this指向的问题，hook在函数组件中不需要通过this.state或者this.fn来获取数据或者方法。</li></ol><h3 style=\"text-align: start;\">缺点</h3><ol><li style=\"text-align: start;\">hooks的useEffect只包括了componentDidMount、componentDidUpdate还有componentWillUnmount这三个生命周期，对于getSnapshotBeforeUpdate和componentDidCatch等其他的生命周期没有支持。</li><li style=\"text-align: start;\">使用useEffect时候里面不能写太多依赖项，将各个不同的功能划分为多个useEffect模块，将各项功能拆开写，这是遵循了软件设计的“单一职责模式”。如果遇到状态不同步的情况，使用手动传递参数的形式。</li><li style=\"text-align: start;\">如果业务复杂，就使用Component代替hooks，hooks的出现并不是取代了class组件，而是在函数组件的基础上可以实现一部分的类似class组件功能。</li></ol><hr/><h2 style=\"text-align: start;\"><a href=\"#classyuhssqb\" name=\"classyuhssqb\">Class组件与函数式组件的区别</a></h2><p style=\"text-align: start;\">类组件是使用ES6 的 class 来定义的组件。 函数组件是接收一个单一的 `props` 对象并返回一个React元素。</p><p style=\"text-align: start;\">关于React的两套API（类（class）API 和基于函数的钩子（hooks） API）。官方推荐使用钩子（函数），而不是类。因为钩子更简洁，代码量少，用起来比较\"轻\"，而类比较\"重\"。而且，钩子是函数，更符合 React 函数式的本质。</p><p style=\"text-align: start;\">函数一般来说，只应该做一件事，就是返回一个值。 如果你有多个操作，每个操作应该写成一个单独的函数。而且，数据的状态应该与操作方法分离。根据函数这种理念，React 的函数组件只应该做一件事情：返回组件的 HTML 代码，而没有其他的功能。函数的返回结果只依赖于它的参数。不改变函数体外部数据、函数执行过程里面没有副作用。</p><h3 style=\"text-align: start;\">类（class）是数据和逻辑的封装。</h3><p style=\"text-align: start;\">也就是说，组件的状态和操作方法是封装在一起的。如果选择了类的写法，就应该把相关的数据和操作，都写在同一个class 里面。</p><h4 style=\"text-align: start;\">类组件的缺点</h4><ol><li style=\"text-align: start;\">大型组件很难拆分和重构，也很难测试。</li><li style=\"text-align: start;\">业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。</li><li style=\"text-align: start;\">组件类引入了复杂的编程模式，比如 render props 和高阶组件。</li><li style=\"text-align: start;\">难以理解的 class，理解 JavaScript 中 `this` 的工作方式。</li></ol><h4 style=\"text-align: start;\">区别</h4><p>函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。</p><ol><li style=\"text-align: start;\">状态的有无</li><li style=\"text-align: start;\">调用方式的不同</li><li style=\"text-align: start;\">因为调用方式不同，在函数组件使用中会出现问题</li></ol><hr/><h2 style=\"text-align: start;\"><a href=\"#gzhs\" name=\"gzhs\">React Hooks钩子函数</a></h2><h3 style=\"text-align: start;\">*Hook* 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</h3><ul><li style=\"text-align: start;\">`useState()` //状态钩子</li><li style=\"text-align: start;\">`useContext()` //共享状态钩子</li><li style=\"text-align: start;\">`useReducer()` //action 钩子</li><li style=\"text-align: start;\">`useEffect()` //副作用钩子</li><li style=\"text-align: start;\">useCallback 记忆函数</li><li style=\"text-align: start;\">useMemo 记忆组件</li><li style=\"text-align: start;\">useRef 保存引用值</li><li style=\"text-align: start;\">useImperativeHandle 穿透 Ref</li><li style=\"text-align: start;\">useLayoutEffect 同步执行副作用</li><li style=\"text-align: start;\">useEffect和useLayoutEffect有什么区别</li></ul><p style=\"text-align: start;\">简单来说就是调用时机不同，useLayoutEffect和原来componentDidMount&amp;componentDidUpdate一致，在react完成DOM更新后马上同步调用的代码，会阻塞页面渲染。而useEffect是会在整个页面渲染完才会调用的代码。`官方建议优先使用useEffect</p><p style=\"text-align: start;\"><br></p><hr/><h2><a href=\"#redux\" name=\"redux\">Redux介绍</a></h2><h3 style=\"text-align: start;\">什么是Redux</h3><p style=\"text-align: start;\">redux是专门用于集中式管理状态的javascript库</p><h3 style=\"text-align: start;\">Redux工作流程</h3><p>分别为actions、store、reducers（带s的表明可能存在多个）</p><ol><li style=\"text-align: start;\">让Action Creators创建action</li><li style=\"text-align: start;\">通过dispatch将action分发出去</li><li style=\"text-align: start;\">store对要使用的reducer进行绑定，然后将action分发到对应的reducer上</li><li style=\"text-align: start;\">在reducer上进行相应的action操作并返回结果给store</li><li style=\"text-align: start;\">组件就可以通过store的API像store进行获取操作返回的结果</li></ol><hr/><h2><a href=\"#txfs\" name=\"txfs\">React组件的通信方式</a></h2><h3 style=\"text-align: start;\">react组件间通信常见的几种情况</h3><ol><li style=\"text-align: start;\">父组件向子组件通信</li><li style=\"text-align: start;\">子组件向父组件通信</li><li style=\"text-align: start;\">跨级组件通信```js<br>// context方式实现跨级组件通信<br>// Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据<br><br>const BatteryContext = createContext();<br><br>// 子组件的子组件</li></ol><pre><code >\nclass GrandChild extends Component {\n  render(){\n    return (\n      &lt;BatteryContext.Consumer&gt;\n    {\n        color =&gt; &lt;h1 style={{\"color\":color}}&gt;我是红色的:{color}&lt;/h1&gt;\n    }\n&lt;/BatteryContext.Consumer&gt;\n    )\n  }\n}\n\n// 子组件\nconst Child = () =&gt;{\n  return (\n    &lt;GrandChild /&gt;\n  )\n}\n// 父组件</code></pre><pre><code >\nclass Parent extends Component {\n  state = {\n    color:\"red\"\n  }\n  render(){\n    const {color} = this.state\n      return (\n        &lt;BatteryContext.Provider value={color}&gt;\n          &lt;Child&gt;&lt;/Child&gt;\n      &lt;/BatteryContext.Provider &gt;\n     )\n  }\n}\n```</code></pre><h4 style=\"text-align: start;\">4.非嵌套关系的组件通信</h4><p style=\"text-align: left;\">即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。</p><ol><li style=\"text-align: left;\">可以使用自定义事件通信（发布订阅模式），使用pubsub-js</li><li style=\"text-align: left;\">可以通过redux等进行全局状态管理</li><li style=\"text-align: left;\">如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。</li><li style=\"text-align: left;\">也可以new一个 NODE 的 EventBus,进行事件监听，一边执行监听，一边执行新增 NODE的eventBus 就是发布订阅模式，是可以在React中使用的;</li></ol><p style=\"text-align: left;\"><br></p><hr/><h2><a href=\"#setstatea\" name=\"setstatea\">setState既存在异步情况也存在同步情况</a></h2><h5 style=\"text-align: start;\">1.异步情况 在`React事件当中是异步操作`</h5><h5 style=\"text-align: start;\">2.同步情况 如果是在`setTimeout事件或者自定义的dom事件`中，都是同步的</h5><pre><code >```js\n//setTimeout事件\nimport React,{ Component } from \"react\";\nclass Count extends Component{\n  constructor(props){\n    super(props);\n    this.state = {\n      count:0\n    }\n  }\n  render(){\n    return (\n      &lt;&gt;\n          &lt;p&gt;count:{this.state.count}&lt;/p&gt;\n          &lt;button onClick={this.btnAction}&gt;增加&lt;/button&gt;\n      &lt;/&gt;\n    )\n  }\n  btnAction = ()=&gt;{\n  //不能直接修改state，需要通过setState进行修改\n  //同步\n    setTimeout(()=&gt;{\n      this.setState({\n        count: this.state.count + 1\n      });\n      console.log(this.state.count);\n    })\n  }\n}\n\nexport default Count;\n```\n```js\n//自定义dom事件\nimport React,{ Component } from \"react\";\nclass Count extends Component{\n  constructor(props){\n    super(props);\n    this.state = {\n      count:0\n    }\n  }\n\n  render(){\n    return (\n    &lt;&gt;\n        &lt;p&gt;count:{this.state.count}&lt;/p&gt;\n        &lt;button id=\"btn\"&gt;绑定点击事件&lt;/button&gt;\n    &lt;/&gt;\n    )\n    }\n\n  componentDidMount(){\n//自定义dom事件，也是同步修改\n    document.querySelector('#btn').addEventListener('click',()=&gt;{\n      this.setState({\n        count: this.state.count + 1\n        });\n      console.log(this.state.count);\n    });\n  }\n}\n\nexport default Count;</code></pre><p><br></p><hr/><h2><a href=\"#fiber\" name=\"fiber\">React-Fiber</a></h2><h3 style=\"text-align: start;\">1）背景</h3><p>react-fiber 产生的根本原因，是`大量的同步计算任务阻塞了浏览器的 UI 渲染`。默认情况下，JS 运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。如果 JS 运算持续占用主线程，页面就没法得到及时的更新。当我们调用`setState`更新页面的时候，React 会遍历应用的所有节点，计算出差异，然后再更新 UI。如果页面元素很多，整个过程占用的时机就可能超过 16 毫秒，就容易出现掉帧的现象。</p><h3 style=\"text-align: start;\">2）实现原理</h3><p>react内部运转分三层：</p><ol><li style=\"text-align: start;\">Virtual DOM 层，描述页面长什么样。</li><li style=\"text-align: start;\">Reconciler 层，负责调用组件生命周期方法，进行 Diff 运算等。</li><li style=\"text-align: start;\">Renderer 层，根据不同的平台，渲染出相应的页面，比较常见的是 ReactDOM 和 ReactNative。</li></ol><p style=\"text-align: start;\">Fiber 其实指的是一种数据结构，它可以用一个纯 JS 对象来表示</p><p style=\"text-align: start;\">```js<br>const fiber = {<br> &nbsp;stateNode, // 节点实例<br> &nbsp;child, // 子节点<br> &nbsp;sibling, // 兄弟节点<br> &nbsp;return, // 父节点<br>}<br>```<br></p><p style=\"text-align: start;\">为了实现不卡顿，就需要有一个调度器 (Scheduler) 来进行任务分配。优先级高的任务（如键盘输入）可以打断优先级低的任务（如Diff）的执行，从而更快的生效。任务的优先级有六种：</p><ol><li style=\"text-align: start;\">synchronous，与之前的Stack Reconciler操作一样，同步执行</li><li style=\"text-align: start;\">task，在next tick之前执行</li><li style=\"text-align: start;\">animation，下一帧之前执行</li><li style=\"text-align: start;\">high，在不久的将来立即执行</li><li style=\"text-align: start;\">low，稍微延迟执行也没关系</li><li style=\"text-align: start;\">offscreen，下一次render时或scroll时才执行</li><li style=\"text-align: start;\">Fiber Reconciler（react ）执行过程分为2个阶段：</li></ol><p style=\"text-align: start;\">生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。阶段一可被打断的特性，让优先级更高的任务先执行，从框架层面大大降低了页面掉帧的概率。</p><p style=\"text-align: start;\">将需要更新的节点一次过批量更新，这个过程不能被打断。</p><p style=\"text-align: start;\">Fiber树：React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为 Virtual DOM Tree，由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node，将 Fiber Node 链接起来的结构成为 Fiber Tree。Fiber Tree 一个重要的特点是链表结构，将递归遍历编程循环遍历，然后配合 requestIdleCallback API, 实现任务拆分、中断与恢复。</p><p style=\"text-align: start;\">从Stack Reconciler到Fiber Reconciler，源码层面其实就是干了一件递归改循环的事情</p><hr/><h2><a href=\"#portals\" name=\"portals\">Portals</a></h2><h5 style=\"text-align: start;\">Portals 提供了一种一流的方式来将子组件渲染到存在于父组件的 DOM 层次结构之外的 DOM 节点中。结构不受外界的控制的情况下就可以使用portals进行创建<br></h5><hr/><h2><a href=\"#ybzjzmsy\" name=\"ybzjzmsy\">何时要使用异步组件？怎么使用？</a></h2><ol><li style=\"text-align: start;\">加载大组件的时候</li><li style=\"text-align: start;\">路由异步加载的时候</li></ol><h3 style=\"text-align: start;\">react 中要配合 Suspense 使用</h3><p style=\"text-align: start;\">```js<br>// 异步懒加载<br>const Box = lazy(()=&gt;import('./components/Box'));<br> &nbsp;// 使用组件的时候要用suspense进行包裹<br> &nbsp;&lt;Suspense fallback={&lt;div&gt;loading...<br> &nbsp; &nbsp;&lt;/div&gt;}&gt;<br> &nbsp;&lt;/Suspense&gt;<br>```</p><hr/><h2><a href=\"#reactbdyl\" name=\"reactbdyl\">React事件绑定原理</a></h2><h2><span style=\"color: rgb(33, 37, 41); background-color: rgb(255, 255, 255); font-size: 14px;\">React并不是将click事件绑在该div的真实DOM上，而是`在document处监听所有支持的事件`，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。</span></h2><hr/><h2><a href=\"#reactlazy\" name=\"reactlazy\">React.lazy()实现的原理</a></h2><h3 style=\"text-align: start;\">React的懒加载示例：</h3><pre><code >``js\nimport React, { Suspense } from 'react';\n\nconst OtherComponent = React.lazy(() =&gt; import('./OtherComponent'));\n\nfunction MyComponent() {\n  return (\n    &lt;div&gt;\n      &lt;Suspense fallback={&lt;div&gt;Loading...\n        &lt;/div&gt;}&gt;\n        &lt;OtherComponent /&gt;\n      &lt;/Suspense&gt;\n    &lt;/div&gt;\n    );\n}\n```</code></pre><p style=\"text-align: start;\">至此，我们分析完了 React 的懒加载原理。简单来说，React利用 React.lazy与import()实现了渲染时的动态加载 ，并利用Suspense来处理异步加载资源时页面应该如何显示的问题。</p><p><br></p>","hrefList":[{"name":"introduce","title":"React介绍"},{"name":"hooksyqd","title":"Hooks的优缺点"},{"name":"classyuhssqb","title":"Class组件与函数式组件的区别"},{"name":"gzhs","title":"React Hooks钩子函数"},{"name":"redux","title":"Redux介绍"},{"name":"txfs","title":"React组件的通信方式"},{"name":"setstatea","title":"setState既存在异步情况也存在同步情况"},{"name":"fiber","title":"React-Fiber"},{"name":"portals","title":"Portals"},{"name":"ybzjzmsy","title":"何时要使用异步组件？怎么使用？"},{"name":"reactbdyl","title":"React事件绑定原理"},{"name":"reactlazy","title":"React.lazy()实现的原理"}],"id":1714807029135,"lookNum":2254},{"title":"Vue","subTitle":"渐进式JavaScript 框架 易学易用，性能出色，适用场景丰富的 Web 前端框架。","label":[],"time":"2024-05-06 00:53:08","uptime":"2024-05-06 00:57:00","creator":"风中追风","type":"tech","abstract":"丰富的、可渐进式集成的生态系统，可以根据应用规模在库和框架间切换自如。","logo":"https://img2.baidu.com/it/u=190784029,513285360&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=640","content":"<h2><a href=\"#smsmvvm\" target=\"\">什么是MVVM</a></h2><p>`视图模型双向绑定`，是`Model-View-ViewModel`的缩写，也就是把`MVC`中的`Controller`演变成`ViewModel。Model`层代表数据模型，`View`代表UI组件，`ViewModel`是`View`和`Model`层的桥梁，数据会绑定到`viewModel`层并自动将数据渲染到页面中，视图变化的时候会通知`viewModel`层更新数据。以前是操作DOM结构更新视图，现在是`数据驱动视图`。</p><p>Vue是一个典型的MVVM框架，模型（Model）只是普通的javascript对象，修改它则试图（View）会自动更新。这种设计让状态管理变得非常简单而直观</p><h3 style=\"text-align: start;\">MVVM的优点</h3><ol><li style=\"text-align: start;\">低耦合`。视图（View）可以独立于Model变化和修改，一个Model可以绑定到不同的View上，当View变化的时候Model可以不变化，当Model变化的时候View也可以不变；</li><li style=\"text-align: start;\">可重用性`。你可以把一些视图逻辑放在一个Model里面，让很多View重用这段视图逻辑。</li><li style=\"text-align: start;\">独立开发`。开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计。</li><li style=\"text-align: start;\">可测试`</li></ol><hr/><h2><a href=\"#sxbdjqx\" target=\"\">Vue数据双向绑定底层实现原理及缺陷</a></h2><h3 style=\"text-align: start;\">实现原理</h3><ol><li style=\"text-align: start;\">Vue 采用数据劫持结合发布者-订阅者模式的方式来实现数据的响应式，</li><li style=\"text-align: start;\">通过Object.defineProperty来劫持数据的setter，getter，在数据变动时发布消息给订阅者，订阅者收到消息后进行相应的处理。</li><li style=\"text-align: start;\">通过原生js提供的监听数据的API，当数据发生变化的时候，在回调函数中修改dom</li></ol><h3 style=\"text-align: start;\">缺陷</h3><ol><li style=\"text-align: start;\">一次性递归到底开销很大，如果数据很大，大量的递归导致调用栈溢出</li><li style=\"text-align: start;\">不能监听对象的新增属性和删除属性</li><li style=\"text-align: start;\">无法正确的监听数组的方法，当监听的下标对应的数据发生改变时不能实时响应</li></ol><hr/><h2><a href=\"#vuesmzq\" target=\"\">Vue生命周期</a></h2><p>每个`Vue`实例在创建时都会经过一系列的初始化过程，`vue`的生命周期钩子，就是说在达到某一阶段或条件时去触发的函数，目的就是为了完成一些动作或者事件</p><ol><li style=\"text-align: start;\">create阶段`：vue实例被创建</li><li style=\"text-align: start;\">beforeCreate`: 最初调用触发，创建前，此时data和methods中的数据都还没有初始化，data和events都不能用</li><li style=\"text-align: start;\">created`： 创建完毕，data中有值，未挂载，data和events已经初始化好，data已经具有响应式；在这里可以发送请求</li><li style=\"text-align: start;\">mount阶段`： vue实例被挂载到真实DOM节点</li><li style=\"text-align: start;\">beforeMount`：在模版编译之后，渲染之前触发，可以发起服务端请求，去数据，ssr中不可用，基本用不上这个hook</li><li style=\"text-align: start;\">mounted`: 在渲染之后触发，此时可以操作DOM，并能访问组件中的DOM以及$ref,SSR中不可用</li><li style=\"text-align: start;\">update阶段`：当vue实例里面的data数据变化时，触发组件的重新渲染</li><ul><li style=\"text-align: left;\">beforeUpdate` :更新前，在数据变化后，模版改变前触发，切勿使用它监听数据变化</li><li style=\"text-align: left;\">updated`：更新后，在数据改变后，模版改变后触发，常用于重渲染案后的打点，性能检测或触发vue组件中非vue组件的更新</li></ul><li style=\"text-align: start;\">destroy阶段`：vue实例被销毁</li></ol><p style=\"text-align: start;\"> &nbsp; &nbsp;beforeDestroy`：实例被销毁前，组件卸载前触发，此时可以手动销毁一些方法，可以在此时清理事件、计时器或者取消订阅操作</p><p style=\"text-align: start;\"> &nbsp; &nbsp;destroyed`:卸载完毕后触发，销毁后，可以做最后的打点或事件触发操作<br></p><hr/><h2><a href=\"#zjdsmzq\" target=\"\">组件的生命周期</a></h2><p>生命周期</p><p style=\"text-align: start;\">（父子组件） 父组件beforeCreate --&gt; 父组件created --&gt; 父组件beforeMount --&gt; 子组件beforeCreate --&gt; 子组件created --&gt;</p><p style=\"text-align: start;\">子组件beforeMount --&gt; 子组件 mounted --&gt; 父组件mounted --&gt;父组件beforeUpdate --&gt;子组件beforeDestroy--&gt; 子组件destroyed --&gt;</p><p style=\"text-align: start;\">父组件updated</p><p style=\"text-align: start;\">加载渲染过程 父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</p><p style=\"text-align: start;\">挂载阶段</p><p style=\"text-align: start;\">父created-&gt;子created-&gt;子mounted-&gt;父mounted</p><p style=\"text-align: start;\">父组件更新阶段</p><p style=\"text-align: start;\">父beforeUpdate-&gt;父updated</p><p style=\"text-align: start;\">子组件更新阶段</p><p style=\"text-align: start;\">父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p><p style=\"text-align: start;\">销毁阶段</p><p style=\"text-align: start;\">父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p><p style=\"text-align: start;\"><br></p><hr/><h2><a href=\"#computedywatch\" target=\"\">Computed与Watch</a></h2><h3 style=\"text-align: start;\">通俗来讲，既能用 computed 实现又可以用 watch 监听来实现的功能，推荐用 computed， 重点在于 computed 的缓存功能 computed</h3><p>计算属性是用来声明式的描述一个值依赖了其它的值，当所依赖的值或者变量 改变时，计算属性也会跟着改变； watch 监听的是已经在 data 中定义的变量，当该变量变化时，会触发 watch 中的方法。</p><p>watch 属性监听</p><p style=\"text-align: start;\">是一个对象，键是需要观察的属性，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作,监听属性的变化，需要在数据变化时执行异步或开销较大的操作时使用</p><p style=\"text-align: start;\">computed 计算属性</p><p style=\"text-align: start;\">属性的结果会被`缓存`，当`computed`中的函数所依赖的属性没有发生改变的时候，那么调用当前函数的时候结果会从缓存中读取。除非依赖的响应式属性变化时才会重新计算，主要当做属性来使用 `computed`中的函数必须用`return`返回最终的结果 `computed`更高效，优先使用。`data 不改变，computed 不更新。`</p><h3 style=\"text-align: start;\">使用场景</h3><p style=\"text-align: start;\">`computed`：当一个属性受多个属性影响的时候使用，例：购物车商品结算功能</p><p style=\"text-align: start;\">`watch`：当一条数据影响多条数据的时候使用，例：搜索数据</p><hr/><h2><a href=\"#datahansu\" target=\"\">组件中Data为什么是一个函数</a></h2><ol><li style=\"text-align: start;\">一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。</li><li style=\"text-align: start;\">如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。</li></ol><p style=\"text-align: start;\"><br></p><hr/><h2><a href=\"#vforvif\" target=\"\">为什么V-for和V-if不建议用在一起</a></h2><ol><li style=\"text-align: start;\">当 v-for 和 v-if 处于同一个节点时，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。如果要遍历的数组很大，而真正要展示的数据很少时，这将造成很大的性能浪费</li><li style=\"text-align: start;\">这种场景建议使用 computed，先对数据进行过滤</li></ol><p style=\"text-align: start;\"><span style=\"color: rgb(225, 60, 57);\">注意：3.x 版本中 `v-if` 总是优先于 `v-for` 生效。由于语法上存在歧义，建议避免在同一元素上同时使用两者。比起在模板层面管理相关逻辑，更好的办法是通过创建计算属性筛选出列表，并以此创建可见元素。</span></p><hr/><h2><a href=\"#keydzy\" target=\"\">React/Vue项目中key的作用</a></h2><h5 style=\"text-align: start;\">key的作用是为了在diff算法执行时更快的找到对应的节点，`提高diff速度，更高效的更新虚拟DOM`;</h5><h5 style=\"text-align: start;\">vue和react都是采用diff算法来对比新旧虚拟节点，从而更新节点。在vue的diff函数中，会根据新节点的key去对比旧节点数组中的key，从而找到相应旧节点。如果没找到就认为是一个新增节点。而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。</h5><h5 style=\"text-align: start;\">为了在数据变化时强制更新组件，以避免`“就地复用”`带来的副作用。</h5><p>当 Vue.js 用 `v-for` 更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM</p><p>元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。重复的key会造成渲染错误。</p><hr/><h2><a href=\"#vuezjdtxfs\" target=\"\">Vue组件的通信方式</a></h2><h2></h2><h3 style=\"text-align: start;\">父子组件通信</h3><p>`props`/`$emit` 父-&gt;子`props`，</p><p>子-&gt;父 `$on、$emit` 获取父子组件实例 `parent、children` ` Ref `获取实例的方式调用组件的属性或者方法</p><p>父-&gt;子孙 `Provide、inject` 官方不推荐使用，但是写组件库时很常用</p><h3 style=\"text-align: start;\">兄弟组件通信</h3><p>`$emit`/`$on` 自定义事件</p><h3 style=\"text-align: start;\">`Event Bus` 实现跨组件通信 `Vue.prototype.$bus = new Vue()` 自定义事件</h3><h3 style=\"text-align: start;\">vuex 跨级组件通信</h3><p>`$attrs、$listeners` `Provide、inject`</p><hr/><h2><a href=\"#nexttick\" target=\"\">NextTick的实现</a></h2><ol><li style=\"text-align: start;\">`nextTick`是`Vue`提供的一个全局`API`,是在下次`DOM`更新循环结束之后执行延迟回调，在修改数据之后使用`$nextTick`，则可以在回调中获取更新后的`DOM`；</li><li style=\"text-align: start;\">Vue在更新DOM时是异步执行的。只要侦听到数据变化，`Vue`将开启1个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个`watcher`被多次触发，只会被推入到队列中-次。这种在缓冲时去除重复数据对于避免不必要的计算和`DOM`操作是非常重要的。`nextTick`方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用；</li><li style=\"text-align: start;\">比如，我在干什么的时候就会使用nextTick，传一个回调函数进去，在里面执行dom操作即可；</li><li style=\"text-align: start;\">我也有简单了解`nextTick`实现，它会在`callbacks`里面加入我们传入的函数，然后用`timerFunc`异步方式调用它们，首选的异步方式会是`Promise`。这让我明白了为什么可以在`nextTick`中看到`dom`操作结果。</li></ol><h3 style=\"text-align: start;\">nextTick的实现原理是什么？</h3><p>在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。 nextTick主要使用了宏任务和微任务。</p><p>根据执行环境分别尝试采用Promise、MutationObserver、setImmediate，如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p><hr/><h2><a href=\"#vuexsycj\" target=\"\">VueX的理解及使用场景</a></h2><h2></h2><h3 style=\"text-align: start;\">Vuex是集中管理项目公共数据的式。每一个 Vuex 应用的核心就是 store（仓库）。VueX在大型项目中比较常用，非关系组件传递数据比较方便。</h3><p>1. Vuex 的状态存储是响应式的；当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新</p><p style=\"text-align: start;\">2. 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation，</p><p style=\"text-align: start;\">这样使得我们可以方便地跟踪每一个状态的变化 Vuex主要包括以下几个核心模块：</p><p style=\"text-align: start;\">1.State：定义了应用的状态数据</p><p style=\"text-align: start;\">2.Getter：在 store 中定义“getter”（可以认为是 store 的计算属性），就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来， 且只有当它的依赖值发生了改变才会被重新计算</p><p style=\"text-align: start;\">3.Mutation：是唯一更改 store 中状态的方法，且必须是同步函数</p><p style=\"text-align: start;\">4.Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作</p><p style=\"text-align: start;\">5.Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中</p>","hrefList":[{"name":"smsmvvm","title":"什么是MVVM"},{"name":"sxbdjqx","title":"Vue数据双向绑定底层实现原理及缺陷"},{"name":"vuesmzq","title":"Vue生命周期"},{"name":"zjdsmzq","title":"组件的生命周期"},{"name":"computedywatch","title":"Computed与Watch"},{"name":"datahansu","title":"组件中Data为什么是一个函数"},{"name":"vforvif","title":"为什么V-for和V-if不建议用在一起"},{"name":"keydzy","title":"React/Vue项目中key的作用"},{"name":"vuezjdtxfs","title":"Vue组件的通信方式"},{"name":"nexttick","title":"NextTick的实现"},{"name":"vuexsycj","title":"VueX的理解及使用场景"}],"id":1714927988798,"lookNum":631},{"title":"常用函数整理","subTitle":"JS常用的函数整理分享","label":[],"time":"2024-05-06 01:17:47","uptime":"2024-05-06 01:17:47","creator":"风中追风","type":"tech","abstract":"加快开发效率，将常用的方法归纳","logo":"https://img0.baidu.com/it/u=3052557625,100943456&fm=253&fmt=auto&app=120&f=JPEG?w=800&h=500","content":"<h2><a href=\"#qffwgfj\" name=\"qffwgfj\">千分位分隔符，格式化价格</a></h2><ol><li style=\"text-align: start;\">str.replace(/(\\d)(?=(?:\\d{3})+$)/g, '$1,')</li><li style=\"text-align: start;\">Number(str).toLocaleString()</li></ol><p style=\"text-align: start;\"><br></p><hr/><h2><a href=\"#yzsjhsfyx\" name=\"yzsjhsfyx\"> 验证手机号是否有效</a></h2><pre><code >function validPhone(phone: string) {\n  var reg='^((13[0-9])|(14[5,7])|(15[0-3,5-9])|(17[0,3,5-9])|(18[0-9])|166|198|199|191|(147))\\\\d{8}$';\n  var regExp=new RegExp(reg);\n  return regExp.test(phone);\n},</code></pre><p><br></p><hr/><h2><a href=\"#yzyxsfyx\" name=\"yzyxsfyx\">验证邮箱是否有效</a></h2><pre><code >functionvalidateEmail(email: string) {\n  const regex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return regex.test(email);\n}</code></pre><p><br></p><hr/><h2><a href=\"#hqwjkzm\" name=\"hqwjkzm\">获取文件扩展名</a></h2><pre><code >function getHouZhui(fileName: string) {\n  return fileName.slice(fileName.lastIndexOf('.'))\n},\n</code></pre><hr/><h2><a href=\"#ffejfla\" name=\"ffejfla\">返回一个长度为参数值并且每项都为参数值的数组</a></h2><pre><code >1、function createArray(number: number) {\n       const arr = [];\n       [...Array(number)].map(() =&gt; arr.push(number));\n       return arr;\n}\n2、function createArray(number: number) {\n       return Array(number).fill(number)\n}\n3、function createArray(number: number) {\n       var kk=number.toString().repeat(number);\n       return kk.split('').map(Number);\n}</code></pre><p><br></p><hr/><h2><a href=\"#hqlgzfcdzczc\" name=\"hqlgzfcdzczc\">获取两个字符串的最长连续子串</a></h2><h3 style=\"text-align: start;\">思路：</h3><p style=\"text-align: start;\">传入两个字符串，先比较谁长谁短，遍历短的字符串，两个for循环，外层循环从最大长度开始遍历，长度逐个递减，内层循环从短字符串的最左边开始截取最大长度的字符串，检查截取的字符串是否在长的字符串里面， 直到找到匹配的字符串</p><p style=\"text-align: start;\">代码</p><pre><code >  function findLongestCommonStr(s1, s2) {\n    var commonStr = '', L1 = s1.length, L2 = s2.length;\n    // 比较s1,s2的长度，看谁长谁短\n    var shortStr = L1&gt;L2 ? s2 : s1;\n    var longStr = L1&gt;L2 ? s1 : s2;\n    // 短的字符串的长度\n    var strLen = shortStr.length;\n\n    // 遍历短的字符串，从大到小递减\n    for (let j = strLen; j &gt; 0; j--) {\n      // 不同的长度有总共有i个可能，从做到右遍历\n      for (let i = 0; i &lt;= strLen - j; i++) {\n        // 截取出短字符串的部分字符串\n         commonStr = shortStr.substr(i, j);\n        // 为了便于观测运行的过程，打印看一下会直观很多\n        console.log('commonStr:',commonStr,'i:',i,'j:',j);\n\n        // 放在长字符串里看看有没有匹配的，如果有直接返回\n        if (longStr.indexOf(commonStr) &gt;= 0) return commonStr\n      }\n    }\n    // 没有的话返回空字符串\n    return ''\n    }</code></pre><p><br></p><hr/><h2><a href=\"#vscodegjh\" name=\"vscodegjh\">VsCode匹配到全部中文（国际化翻译的时候用到）</a></h2><p><span style=\"color: rgb(33, 37, 41); background-color: rgb(255, 255, 255);\">(\".*[\\u4E00-\\u9FA5]+)|([\\u4E00-\\u9FA5]+.*\")</span></p>","hrefList":[{"name":"qffwgfj","title":"千分位分隔符，格式化价格"},{"name":"yzsjhsfyx","title":" 验证手机号是否有效"},{"name":"yzyxsfyx","title":"验证邮箱是否有效"},{"name":"hqwjkzm","title":"获取文件扩展名"},{"name":"ffejfla","title":"返回一个长度为参数值并且每项都为参数值的数组"},{"name":"hqlgzfcdzczc","title":"获取两个字符串的最长连续子串"},{"name":"vscodegjh","title":"VsCode匹配到全部中文（国际化翻译的时候用到）"}],"id":1714929467115,"lookNum":520},{"title":"CSS","subTitle":"层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。","label":[],"time":"2024-05-06 01:26:07","uptime":"2024-05-06 01:28:10","creator":"风中追风","type":"tech","abstract":"CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。 [1] CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。 [2]","logo":"https://img2.baidu.com/it/u=4268086562,2296722119&fm=253&fmt=auto&app=138&f=JPEG?w=640&h=427","content":"<h2><a href=\"#xy\" name=\"xy\"=\"\" style=\"text-align: start;\">CSS 选择器及优先级</a></h2><h3 style=\"text-align: start;\">选择器：</h3><ol><li style=\"text-align: start;\">id选择器(#myid)</li><li style=\"text-align: start;\">类选择器(.myclass)</li><li style=\"text-align: start;\">属性选择器(a[rel=\"external\"])</li><li style=\"text-align: start;\">伪类选择器(a:hover, li:nth-child)</li><li style=\"text-align: start;\">标签选择器(div, h1,p)</li><li style=\"text-align: start;\">相邻选择器（h1 + p）</li><li style=\"text-align: start;\">子选择器(ul &gt; li)</li><li style=\"text-align: start;\">后代选择器(li a)</li><li style=\"text-align: start;\">通配符选择器(*)</li></ol><h3 style=\"text-align: start;\">优先级：</h3><ul><li style=\"text-align: start;\">!important</li><li style=\"text-align: start;\">内联样式（1000）</li><li style=\"text-align: start;\">ID选择器（0100）</li><li style=\"text-align: start;\">类选择器/属性选择器/伪类选择器（0010）</li><li style=\"text-align: start;\">元素选择器/伪元素选择器（0001）</li><li style=\"text-align: start;\">关系选择器/通配符选择器（0000）</li></ul><p style=\"text-align: start;\">带!important 标记的样式属性优先级最高； 样式表的来源相同时：</p><p style=\"text-align: start;\">!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</p><hr/><h2><a href=\"#JJZQ\" name=\"JJZQ\"=\"\" style=\"text-align: start;\">渐进增强与优雅降级的理解及区别</a></h2><h3 style=\"text-align: start;\">渐进增强（Progressive Enhancement）：</h3><p style=\"text-align: start;\">一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。</p><h3 style=\"text-align: start;\">优雅降级（Graceful Degradation）：</h3><p style=\"text-align: start;\">一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。</p><h3 style=\"text-align: start;\">两者区别</h3><ol><li style=\"text-align: start;\">广义： 其实要定义一个基准线，在此之上的增强叫做渐进增强，在此之下的兼容叫优雅降级</li><li style=\"text-align: start;\">狭义： 渐进增强一般说的是使用CSS3技术，在不影响老浏览器的正常显示与使用情形下来增强体验，而优雅降级则是体现html标签的语义，以便在js/css的加载失败/被禁用时，也不影响用户的相应功能。</li><li style=\"text-align: start;\">代码展示<span style=\"color: rgb(33, 37, 41); font-size: 14px;\">css<br>.transition { /*渐进增强写法*/<br>-webkit-transition: all .5s;<br>-moz-transition: all .5s;<br>-o-transition: all .5s;<br>transition: all .5s;<br>}<br>.transition { /*优雅降级写法*/<br>transition: all .5s;<br>-o-transition: all .5s;<br>-moz-transition: all .5s;<br>-webkit-transition: all .5s;<br>}<br></span></li></ol><hr/><h2><a href=\"#jrwt\" name=\"jrwt\"=\"\" style=\"text-align: start;\">常见的兼容性问题</a></h2><ol><li style=\"text-align: start;\">不同浏览器的标签默认的margin和padding不一样。*{margin:0;padding:0;}</li><li style=\"text-align: start;\">IE6双边距bug：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大。hack：display:inline;将其转化为行内属性。</li><li style=\"text-align: start;\">设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度。hack：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。</li><li style=\"text-align: start;\">Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。</li><li style=\"text-align: start;\">超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了。解决方法是改变CSS属性的排列顺序:L-V-H-A ( love hate ): a:link {} a:visited {} a:hover {} a:active {}</li></ol><hr/><h2><a href=\"#newtx\" name=\"newtx\"=\"\" style=\"text-align: start;\">CSS3新特性</a></h2><p>1、过渡<span style=\"color: rgb(33, 37, 41); font-size: 14px;\">```js<br>/*所有属性从原始值到制定值的一个过渡，运动曲线ease,运动时间0.5秒*/<br>transition：all,.5s<br>```<br></span></p><p>2、动画<span style=\"color: rgb(33, 37, 41); font-size: 14px;\">```js<br>//animation：动画名称，一个周期花费时间，运动曲线（默认ease），动画延迟（默认0），播放次数（默认1），是否反向播放动画（默认normal），是否暂停动画（默认running）<br>/*执行一次logo2-line动画，运动时间2秒，运动曲线为 linear*/<br>animation: logo2-line 2s linear;<br>```</span></p><p>3、形状转换<span style=\"color: rgb(33, 37, 41); font-size: 14px;\">```js<br>//transform:适用于2D或3D转换的元素<br>//transform-origin：转换元素的位置（围绕那个点进行转换）。默认(x,y,z)：(50%,50%,0)<br>transform:translate(30px,30px);<br>transform:rotate(30deg);<br>transform:scale(.8);<br>```</span></p><p>4、选择器:nth-of-type()</p><p>5、阴影</p><p style=\"text-align: start;\">文字阴影: text-shadow: 2px 2px 2px #000;(水平阴影，垂直阴影，模糊距离，阴影颜色)</p><p style=\"text-align: start;\">盒子阴影: box-shadow: 10px 10px 5px #999</p><p style=\"text-align: start;\">6、边框</p><p style=\"text-align: start;\">border-image: url(border.png);</p><p style=\"text-align: start;\">7、背景</p><p style=\"text-align: start;\">8、文字</p><p style=\"text-align: start;\">9、渐变</p><p style=\"text-align: start;\">10、Filter（滤镜）</p><p style=\"text-align: start;\">11、弹性布局、栅格布局、多列布局</p><p style=\"text-align: start;\">12、媒体查询</p><hr/><h2><a href=\"#positiona\" name=\"positiona\"=\"\" style=\"text-align: start;\">position 属性的值有哪些及其区别</a></h2><ol><li style=\"text-align: start;\">相对定位 relative： 如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直 或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是 否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。</li><li style=\"text-align: start;\">绝对定位 absolute： 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那 么它的位置相对于。absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。</li><li style=\"text-align: start;\">粘性定位 sticky： 元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定 位，之后为固定定位。</li><li style=\"text-align: start;\">默认定位 Static： 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声 明）。 inherit: 规定应该从父元素继承 position 属性的值</li></ol><hr/><h2><a href=\"#boxsizing\" name=\"boxsizing\"=\"\" style=\"text-align: start;\">box-sizing属性</a></h2><p style=\"text-align: start;\">box-sizing 规定两个并排的带边框的框，语法为 box-sizing：content-box/border-box/inherit</p><p style=\"text-align: start;\">content-box：宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框。[标准盒子模型]</p><p style=\"text-align: start;\">border-box：为元素设定的宽度和高度决定了元素的边框盒。【IE 盒子模型】</p><p style=\"text-align: start;\">inherit：继承父元素的 box-sizing 值。</p><hr/><h2><a href=\"#hzmx\" name=\"hzmx\"=\"\" style=\"text-align: start;\">CSS 盒子模型</a></h2><p style=\"text-align: start;\">CSS 盒模型本质上是一个盒子，它包括：边距，边框，填充和实际内容。CSS 中的盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。</p><p style=\"text-align: start;\">在标准的盒子模型中，`width 指 content 部分的宽度`。</p><p style=\"text-align: start;\">在 IE 盒子模型中，`width 表示 content+padding+border 这三个部分的宽度`。</p><p style=\"text-align: start;\">故在计算盒子的宽度时存在差异：</p><p style=\"text-align: start;\">标准盒模型： 一个块的总宽度 = width+margin(左右)+padding(左右)+border(左右)</p><p style=\"text-align: start;\">怪异盒模型： 一个块的总宽度 = width+margin（左右）（既 width 已经包含了 padding 和 border 值）</p><hr/><h2><a href=\"#kjzyy\" name=\"kjzyy\"=\"\" style=\"text-align: start;\">BFC（块级格式上下文）</a></h2><h3 style=\"text-align: start;\">BFC的概念</h3><p style=\"text-align: start;\">块级格式化上下文、独立的渲染区域、不会影响边界以外的元素</p><h3 style=\"text-align: start;\">BFC的原理布局规则</h3><ol><li style=\"text-align: start;\">内部的Box会在`垂直方向`，一个接一个地放置</li><li style=\"text-align: start;\">Box`垂直方向的距离由margin决定`。属于同一个BFC的两个相邻Box的margin会发生重叠</li><li style=\"text-align: start;\">每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)</li><li style=\"text-align: start;\">BFC的区域`不会与float box重叠`</li><li style=\"text-align: start;\">BFC是一个独立容器，容器里面的`子元素不会影响到外面的元素`</li><li style=\"text-align: start;\">计算BFC的高度时，`浮动元素也参与计算高度`</li><li style=\"text-align: start;\">元素的类型和`display属性，决定了这个Box的类型`。不同类型的Box会参与不同的`Formatting Context`。</li></ol><h3 style=\"text-align: start;\">如何创建BFC？</h3><ol><li style=\"text-align: start;\">根元素，即HTML元素</li><li style=\"text-align: start;\">float的值不为none</li><li style=\"text-align: start;\">position为absolute或fixed</li><li style=\"text-align: start;\">display的值为flex、inline-block、table-cell、table-caption</li><li style=\"text-align: start;\">overflow的值不为visible</li></ol><h3 style=\"text-align: start;\">BFC的使用场景</h3><ol><li style=\"text-align: start;\">去除边距重叠现象</li><li style=\"text-align: start;\">清除浮动（让父元素的高度包含子浮动元素）</li><li style=\"text-align: start;\">避免某元素被浮动元素覆盖</li><li style=\"text-align: start;\">避免多列布局由于宽度计算四舍五入而自动换行</li></ol><hr/><h2><a href=\"#ysjzhh\" name=\"ysjzhh\"=\"\" style=\"text-align: start;\">让一个元素水平垂直居中</a></h2><h3 style=\"text-align: start;\">水平居中</h3><p style=\"text-align: start;\">1、对于行内元素 :</p><p style=\"text-align: start;\">`text-align: center`;</p><p style=\"text-align: start;\">2、对于确定宽度的块级元素：</p><ol><li style=\"text-align: start;\">width和margin实现。`margin: 0 auto`;</li><li style=\"text-align: start;\">绝对定位和margin-left: margin-left: (父width - 子width）/2, 前提是父元素position: relative</li></ol><p style=\"text-align: start;\">3、对于宽度未知的块级元素</p><ol><li style=\"text-align: start;\">`table标签配合margin左右auto实现水平居中`。使用table标签（或直接将块级元素设值为 display:table），再通过给该标签添加左右margin为auto。</li><li style=\"text-align: start;\">inline-block实现水平居中方法。display：inline-block和text-align:center实现水平居中。</li><li style=\"text-align: start;\">`绝对定位+transform`，translateX可以移动本身元素的50%。</li><li style=\"text-align: start;\">flex布局使用`justify-content:center`</li></ol><h3 style=\"text-align: start;\">垂直居中</h3><ol><li style=\"text-align: start;\">利用 `line-height` 实现居中，这种方法适合纯文字类</li><li style=\"text-align: start;\">通过设置父容器 相对定位 ，子级设置 `绝对定位`，标签通过margin实现自适应居中</li><li style=\"text-align: start;\">弹性布局 flex :父级设置display: flex; 子级设置margin为auto实现自适应居中</li><li style=\"text-align: start;\">父级设置相对定位，子级设置绝对定位，并且通过位移 transform 实现</li><li style=\"text-align: start;\">`table 布局`，父级通过转换成表格形式，`然后子级设置 vertical-align 实现`。</li></ol><p style=\"text-align: start;\">传送门 ☞ [# 图解CSS水平垂直居中常见面试方法](https://juejin.cn/post/7008348524530106381)</p><hr/><h2><a href=\"#hideys\" name=\"hideys\"=\"\" style=\"text-align: start;\">隐藏页面中某个元素的方法</a></h2><ol><li style=\"text-align: start;\">`opacity：0`，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定 一些事件，如click 事件，那么点击该区域，也能触发点击事件的</li><li style=\"text-align: start;\">`visibility：hidden`，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已 经绑定的事件 ，隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</li><li style=\"text-align: start;\">`display：none`，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素。 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）</li></ol><hr/><h2><a href=\"#sjfh\" name=\"sjfh\"=\"\" style=\"text-align: start;\">用CSS实现三角符号</a><br><span style=\"color: rgb(33, 37, 41); font-size: 14px;\">```css<br>/*记忆口诀：盒子宽高均为零，三面边框皆透明。 */<br>div:after{<br>position: absolute;<br>width: 0px;<br>height: 0px;<br>content: \" \";<br>border-right: 100px solid transparent;<br>border-top: 100px solid #ff0;<br>border-left: 100px solid transparent;<br>border-bottom: 100px solid transparent;<br>}<br></span></h2><hr/><h2><a href=\"#ymbj\" name=\"ymbj\"=\"\" style=\"text-align: start;\">页面布局</a></h2><h3 style=\"text-align: start;\">1.Flex 布局<span style=\"color: rgb(33, 37, 41); font-size: 14px;\">布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。<br>Flex 是 Flexible Box 的缩写，意为\"弹性布局\",用来为盒状模型提供最大的灵活性。指定容器 display: flex 即可。 简单的分为容器属性和元素属性。<br></span></h3><p>容器的属性：<span style=\"color: rgb(33, 37, 41); font-size: 14px;\">flex-direction：决定主轴的方向（即子 item 的排列方法）flex-direction: row | row-reverse | column | column-reverse;<br>flex-wrap：决定换行规则 flex-wrap: nowrap | wrap | wrap-reverse;<br>flex-flow： .box { flex-flow: || ; }<br>justify-content：对其方式，水平主轴对齐方式<br>align-items：对齐方式，竖直轴线方向<br>align-content<br></span></p><p>项目的属性（元素的属性）：<span style=\"color: rgb(33, 37, 41); font-size: 14px;\">order 属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为 0<br>flex-grow 属性：定义项目的放大比例，即使存在空间，也不会放大<br>flex-shrink 属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果 定义个 item 的 flow-shrink 为 0，则为不缩小<br>flex-basis 属性：定义了在分配多余的空间，项目占据的空间。<br>flex：是 flex-grow 和 flex-shrink、flex-basis 的简写，默认值为 0 1 auto。<br>align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖<br>align-items，默认属 性为 auto，表示继承父元素的 align-items 比如说，用 flex 实现圣杯布局<br></span></p><h3 style=\"text-align: start;\">2.Rem 布局<span style=\"color: rgb(33, 37, 41); font-size: 14px;\">首先 Rem 相对于根(html)的 font-size 大小来计算。简单的说它就是一个相对单例 如:font-size:10px;,那么（1rem = 10px）了解计算原理后首先解决怎么在不同设备上设置 html 的 font-size 大小。其实 rem 布局的本质是等比缩放，一般是基于宽度。<br>优点：可以快速适用移动端布局，字体，图片高度<br>缺点：<br>①目前 ie 不支持，对 pc 页面来讲使用次数不多；<br>②数据量大：所有的图片，盒子都需要我们去给一个准确的值；才能保证不同机型的适配；<br>③在响应式布局中，必须通过 js 来动态控制根元素 font-size 的大小。也就是说 css 样式和 js 代码有一定的耦合性。且必须将改变 font-size 的代码放在 css 样式之前。<br></span></h3><h3 style=\"text-align: start;\">3.百分比布局<span style=\"color: rgb(33, 37, 41); font-size: 14px;\">通过百分比单位 \" % \" 来实现响应式的效果。<br>通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。<br>直观的理解，我们可能会认为子元素的百分比完全相对于直接父元素，height 百分比相 对于 height，width 百分比相对于 width。 padding、border、margin 等等不论是垂直方向还是水平方向，都相对于直接父元素的 width。<br>除了 border-radius外，还有比如 translate、background-size 等都是相对于自身的。<br>缺点：<br>（1）计算困难<br>（2）各个属性中如果使用百分比，相对父元素的属性并不是唯一的。造成我们使用百分比单位容易使布局问题变得复杂。<br></span></h3><h3 style=\"text-align: start;\">4.浮动布局<span style=\"color: rgb(33, 37, 41); font-size: 14px;\">浮动布局:当元素浮动以后可以向左或向右移动，直到它的外边缘碰到包含它的框或者另外一个浮动元素的边框为止。元素浮动以后会脱离正常的文档流，所以文档的普通流中的框就变的好像浮动元素不存在一样。<br>优点<br>这样做的优点就是在图文混排的时候可以很好的使文字环绕在图片周围。另外当元素浮动了起来之后，它有着块级元素的一些性质例如可以设置宽高等，但它与inline-block还是有一些区别的，第一个就是关于横向排序的时候，float可以设置方向而inline-block方向是固定的；还有一个就是inline-block在使用时有时会有空白间隙的问题<br>缺点<br>最明显的缺点就是浮动元素一旦脱离了文档流，就无法撑起父元素，`会造成父级元素高度塌陷`。<br></span></h3><hr/><h2><a href=\"#syrem\" name=\"syrem\"=\"\" style=\"text-align: start;\">如何使用rem或viewport进行移动端适配</a></h2><h5 style=\"text-align: start;\">rem适配原理<span style=\"color: rgb(33, 37, 41); font-size: 14px;\">改变了一个元素在不同设备上占据的css像素的个数<br></span></h5><p>rem适配的优缺点<span style=\"color: rgb(33, 37, 41); font-size: 14px;\">- 优点：没有破坏完美视口<br>- 缺点：px值转换rem太过于复杂(下面我们使用less来解决这个问题)<br></span></p><h2>viewport适配的原理<span style=\"color: rgb(33, 37, 41); font-size: 14px;\">viewport适配方案中，每一个元素在不同设备上占据的css像素的个数是一样的。但是css像素和物理像素的比例是不一样的，等比的<br>viewport适配的优缺点<br>- 在我们设计图上所量取的大小即为我们可以设置的像素大小，即所量即所设<br>- 缺点破坏完美视口<br></span><a href=\"#clearfd\" name=\"clearfd\"=\"\" style=\"text-align: start;\">清除浮动的方式</a></h2><h3 style=\"text-align: start;\">1、添加额外标签<span style=\"color: rgb(33, 37, 41); font-size: 14px;\">```html<br>//div class=\"parent\"&gt;<br>//添加额外标签并且添加clear属性<br>//div style=\"clear:both\"&gt;//div&gt;<br>//也可以加一个br标签<br>//div&gt;<br>```<br></span></h3><h3 style=\"text-align: start;\">2、父级添加overflow属性，或者设置高度</h3><h3 style=\"text-align: start;\">3、建立伪类选择器清除浮动</h3><h5 style=\"text-align: start;\"><span style=\"color: rgb(33, 37, 41); font-size: 14px;\">```js<br>//在css中添加:after伪元素<br>.parent:after{<br>/* 设置添加子元素的内容是空 */<br>content: '';<br>/* 设置添加子元素为块级元素 */<br>display: block;<br>/* 设置添加的子元素的高度0 */<br>height: 0;<br>/* 设置添加子元素看不见 */<br>visibility: hidden;<br>/* 设置clear：both */<br>clear: both;<br>}<br>```<br></span></h5><hr/><h2><a href=\"#yclqsass\" name=\"yclqsass\"=\"\" style=\"text-align: start;\">CSS预处理器Sass、Less、Stylus的区别</a></h2><h5 style=\"text-align: start;\">什么是CSS预处理器?<span style=\"color: rgb(33, 37, 41); font-size: 14px;\">CSS预处理器是一种语言用来为CSS增加一些变成的特性，无需考虑浏览器兼容问题，例如你可以在CSS中使用变量，简单的程序逻辑、函数等在编程语言中的一些基本技巧，可以让CSS更加简洁，适应性更强，代码更直观等诸多好处 基本语法区别<br>Sass是以.sass为扩展名，Less是以.less为扩展名，Stylus是以.styl为扩展名<br>变量的区别<br>Sass 变量必须是以`$`开头的，然后变量和值之间使用冒号（：）隔开，和css属性是一样的。<br>Less 变量是以` @ `开头的，其余sass都是一样的。<br>Stylus 对变量是没有任何设定的，可以是以$开头或者任意字符，而且变量之间可以冒号，空格隔开，但是在stylus中不能用@开头<br>三种预处理器都有：嵌套、运算符、颜色函数、导入、继承、混入。Stylus还有一些高级特性。例如循环、判断等</span></h5>","hrefList":[{"name":"xy","title":"CSS 选择器及优先级"},{"name":"JJZQ","title":"渐进增强与优雅降级的理解及区别"},{"name":"jrwt","title":"常见的兼容性问题"},{"name":"newtx","title":"CSS3新特性"},{"name":"positiona","title":"position 属性的值有哪些及其区别"},{"name":"boxsizing","title":"box-sizing属性"},{"name":"hzmx","title":"CSS 盒子模型"},{"name":"kjzyy","title":"BFC（块级格式上下文）"},{"name":"ysjzhh","title":"让一个元素水平垂直居中"},{"name":"hideys","title":"隐藏页面中某个元素的方法"},{"name":"sjfh","title":"用CSS实现三角符号"},{"name":"ymbj","title":"页面布局"},{"name":"syrem","title":"如何使用rem或viewport进行移动端适配"},{"name":"clearfd","title":"清除浮动的方式"},{"name":"yclqsass","title":"CSS预处理器Sass、Less、Stylus的区别"}],"id":1714929967731,"lookNum":2279}]