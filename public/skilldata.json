[{"title":"HTML5","subTitle":"超文本标记语言用于创建网页的标准标记语言","label":[],"time":"2024-04-14 03:18:53","uptime":"2024-05-04 15:25:42","creator":"风中追风","type":"tech","abstract":"您可以使用 HTML 来建立自己的 WEB 站点，HTML 运行在浏览器上，由浏览器来解析","logo":"https://img0.baidu.com/it/u=2729549399,1815700033&fm=253&fmt=auto&app=138&f=JPEG?w=507&h=507","content":"<h2 style=\"text-align: start;\"><a href=\"#new\" target=\"\">HTML5新标签</a></h2><table style=\"width: auto; text-align: start;\"><tbody><tr><th colspan=\"1\" rowspan=\"1\" width=\"110\" style=\"text-align: left;\">标签</th><th colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: left;\">描述</th></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;audio&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义音频内容</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;video&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义视频（video 或者 movie）</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;source&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义多媒体资源 &lt;video&gt; 和 &lt;audio&gt;</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;embed&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义嵌入的内容，比如插件。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;track&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">为诸如 &lt;video&gt; 和 &lt;audio&gt; 元素之类的媒介规定外部文本轨道。</td></tr></tbody></table><table style=\"width: auto; text-align: start;\"><tbody><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;article&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义页面独立的内容区域。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;aside&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义页面的侧边栏内容。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;bdi&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">允许您设置一段文本，使其脱离其父元素的文本方向设置。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;command&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义命令按钮，比如单选按钮、复选框或按钮</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;details&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">用于描述文档或文档某个部分的细节</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;dialog&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义对话框，比如提示框</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;summary&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">标签包含 details 元素的标题</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;figure&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">规定独立的流内容（图像、图表、照片、代码等等）。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;figcaption&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义 &lt;figure&gt; 元素的标题</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;footer&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义 section 或 document 的页脚。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;header&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义了文档的头部区域</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;mark&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义带有记号的文本。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;meter&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义度量衡。仅用于已知最大和最小值的度量。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;nav&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义导航链接的部分。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;progress&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义任何类型的任务的进度。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;ruby&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义 ruby 注释（中文注音或字符）。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;rt&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义字符（中文注音或字符）的解释或发音。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;rp&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;section&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义文档中的节（section、区段）。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;time&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">定义日期或时间。</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">&lt;wbr&gt;</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">规定在文本中的何处适合添加换行符。</td></tr></tbody></table><h2 style=\"text-align: start;\"><a href=\"#storage\" target=\"\">WEB本地存储</a></h2><p style=\"text-align: start;\">使用HTML5可以在本地存储用户的浏览数据。</p><p style=\"text-align: start;\">早些时候,本地存储使用的是 cookie。但是Web 存储需要更加的安全与快速. 这些数据不会被保存在服务器上，但是这些数据只用于用户请求网站数据上.它也可以存储大量的数据，而不影响网站的性能.</p><p style=\"text-align: start;\">数据以 键/值 对存在, web网页的数据只允许该网页访问使用。</p><h3 style=\"text-align: start;\">localStorage 和 sessionStorage </h3><p style=\"text-align: start;\">客户端存储数据的两个对象为：</p><ul><li style=\"text-align: start;\">localStorage - 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。</li><li style=\"text-align: start;\">sessionStorage - 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。</li></ul><p style=\"text-align: start;\">不管是 localStorage，还是 sessionStorage，可使用的API都相同，常用的有如下几个（以localStorage为例）：</p><ul><li style=\"text-align: start;\">保存数据：localStorage.setItem(key,value);</li><li style=\"text-align: start;\">读取数据：localStorage.getItem(key);</li><li style=\"text-align: start;\">删除单个数据：localStorage.removeItem(key);</li><li style=\"text-align: start;\">删除所有数据：localStorage.clear();</li><li style=\"text-align: start;\">得到某个索引的key：localStorage.key(index);</li></ul><h2 style=\"text-align: start;\"><a href=\"#worker\" target=\"\">WEB WORKER</a></h2><p style=\"text-align: start;\">web worker 是运行在后台的 JavaScript，不会影响页面的性能。</p><h3 style=\"text-align: start;\">什么是 Web Worker？</h3><p style=\"text-align: start;\">当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。</p><p style=\"text-align: start;\">web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</p><pre><code >\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt; \n&lt;meta charset=\"utf-8\"&gt; \n&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; \n&lt;/head&gt;\n&lt;body&gt;\n \n&lt;p&gt;计数： &lt;output id=\"result\"&gt;&lt;/output&gt;&lt;/p&gt;\n&lt;button onclick=\"startWorker()\"&gt;开始工作&lt;/button&gt; \n&lt;button onclick=\"stopWorker()\"&gt;停止工作&lt;/button&gt;\n \n&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; Internet Explorer 9 及更早 IE 版本浏览器不支持 Web Workers.&lt;/p&gt;\n \n&lt;script&gt;\nvar w;\n \nfunction startWorker() {\n    if(typeof(Worker) !== \"undefined\") {\n        if(typeof(w) == \"undefined\") {\n            w = new Worker(\"demo_workers.js\");\n        }\n        w.onmessage = function(event) {\n            document.getElementById(\"result\").innerHTML = event.data;\n        };\n    } else {\n        document.getElementById(\"result\").innerHTML = \"抱歉，你的浏览器不支持 Web Workers...\";\n    }\n}\n \nfunction stopWorker() \n{ \n    w.terminate();\n    w = undefined;\n}\n&lt;/script&gt;\n \n&lt;/body&gt;\n&lt;/html&gt;</code></pre><h2 style=\"text-align: start;\"><a href=\"#websocket\" target=\"\">WEBSOCKET</a></h2><p style=\"text-align: start;\">WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p><p style=\"text-align: start;\">WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><p style=\"text-align: start;\">在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p><p style=\"text-align: start;\">现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。</p><p style=\"text-align: start;\">HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。</p><pre style=\"text-align: start;\"><code>var Socket = new WebSocket(url, [protocol] );</code></pre><h2 style=\"text-align: start;\">WebSocket 事件</h2><p style=\"text-align: start;\">以下是 WebSocket 对象的相关事件。假定我们使用了以上代码创建了 Socket 对象：</p><table style=\"width: auto; text-align: start;\"><tbody><tr><th colspan=\"1\" rowspan=\"1\" width=\"10%\" style=\"text-align: left;\">事件</th><th colspan=\"1\" rowspan=\"1\" width=\"25%\" style=\"text-align: left;\">事件处理程序</th><th colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: left;\">描述</th></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">open</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">Socket.onopen</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">连接建立时触发</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">message</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">Socket.onmessage</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">客户端接收服务端数据时触发</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">error</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">Socket.onerror</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">通信发生错误时触发</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">close</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">Socket.onclose</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">连接关闭时触发</td></tr></tbody></table><h2 style=\"text-align: start;\">WebSocket 方法</h2><p style=\"text-align: start;\">以下是 WebSocket 对象的相关方法。假定我们使用了以上代码创建了 Socket 对象：</p><table style=\"width: auto; text-align: start;\"><tbody><tr><th colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: left;\">方法</th><th colspan=\"1\" rowspan=\"1\" width=\"auto\" style=\"text-align: left;\">描述</th></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">Socket.send()</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">使用连接发送数据</td></tr><tr><td colspan=\"1\" rowspan=\"1\" width=\"auto\">Socket.close()</td><td colspan=\"1\" rowspan=\"1\" width=\"auto\">关闭连接</td></tr></tbody></table><p><br></p>","id":1713035933923,"lookNum":62,"hrefList":[{"name":"new","title":"HTML5新标签"},{"name":"storage","title":"WEB本地存储"},{"name":"worker","title":"WEB WORKER"},{"name":"websocket","title":"WEBSOCKET"}]},{"title":"JavaScript","subTitle":"JavaScript是Web的编程语言","label":[],"time":"2024-04-14 14:26:10","uptime":"2024-05-04 15:43:24","creator":"风中追风","type":"tech","abstract":"JavaScript 是互联网上最流行的脚本语言，广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备","logo":"https://img1.baidu.com/it/u=3914712667,2479801161&fm=253&fmt=auto&app=138&f=JPEG?w=524&h=524","content":"<h2><a href=\"#jsbzsjlx\" name=\"jsbzsjlx\">JS中的8种数据类型及区别</a></h2><p>包括值类型(基本对象类型)和引用类型(复杂对象类型)<span style=\"color: rgb(33, 37, 41); background-color: rgb(255, 255, 255); font-size: 14px;\"><br></span></p><h3 style=\"text-align: start;\">基本值类型</h3><ol><li style=\"text-align: left;\">Number(数字)</li><li style=\"text-align: left;\">String(字符串)</li><li style=\"text-align: left;\">Symbol(符号)</li><li style=\"text-align: left;\">BigInt</li><li style=\"text-align: left;\">Boolean(布尔)</li><li style=\"text-align: left;\">null(空)</li><li style=\"text-align: left;\">undefined(未定义)在内存中占据固定大小，保存在栈内存中</li></ol><h3 style=\"text-align: left;\"><span style=\"color: rgb(33, 37, 41); background-color: rgb(255, 255, 255);\">引用复杂数据类型</span></h3><ol><li style=\"text-align: left;\">Object(对象)</li><li style=\"text-align: left;\">Function(函数)</li><li style=\"text-align: left;\">Array(数组)</li><li style=\"text-align: left;\">Date(日期)</li><li style=\"text-align: left;\">RegExp(正则表达式)</li><li style=\"text-align: left;\">Map(键控集合)</li></ol><h5 style=\"text-align: start;\">本质区别：</h5><p style=\"text-align: start;\">基本数据类型和引用数据类型它们在内存中的存储方式不同。<br>基本数据类型是直接存储在栈中的简单数据段，占据空间小，属于被频繁使用的数据。<br>引用数据类型是存储在堆内存中，占据空间大。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址，当解释器寻找引用值时，会检索其在栈中的地址，取得地址后从堆中获得实体。</p><h5 style=\"text-align: start;\">使用场景：</h5><p style=\"text-align: start;\">Symbol：使用Symbol来作为对象属性名(key) 利用该特性，把一些不需要对外操作和访问的属性使用Symbol来定义</p><p style=\"text-align: start;\">BigInt：由于在 Number 与 BigInt 之间进行转换会损失精度，因而建议仅在值可能大于2的253次方 时使用 BigInt 类型，并且不在两种类型之间进行相互转换。</p><h3 style=\"text-align: start;\">深拷贝、浅拷贝</h3><h5 style=\"text-align: start;\">区别</h5><p style=\"text-align: start;\">如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝；如果B没变，那就是深拷贝。</p><p style=\"text-align: start;\">基本数据类型保存在栈内存，引用类型保存在堆内存中。根本原因在于保存在栈内存的必须是大小固定的数据，引用类型的大小不固定，只能保存在堆内存中，但是可以把它的地址写在栈内存中以供我们访问。</p><h5 style=\"text-align: start;\">浅拷贝</h5><ol><li style=\"text-align: start;\">直接赋值</li></ol><h5 style=\"text-align: start;\">深拷贝<span style=\"color: rgb(33, 37, 41); background-color: rgb(255, 255, 255); font-size: 14px;\">对象深拷贝</span></h5><ol><li style=\"text-align: start;\">先JSON.String然后再JSON.parse回来(没法拷贝内部函数)</li><li style=\"text-align: start;\">Object.Assign(对象的属性值为基本数据类型)</li><li style=\"text-align: start;\">使用...解构(es6的展开语法只针对第一层，对多层还是浅拷贝方式)<span style=\"color: rgb(33, 37, 41); background-color: rgb(255, 255, 255); font-size: 14px;\">数组深拷贝</span></li><li style=\"text-align: start;\">for循环实现</li><li style=\"text-align: start;\">slice方法，将原数组中抽离部分出来形成一个新数组。我们只要设置为抽离全部<br>var arr2 = arr.slice(0)</li><li style=\"text-align: start;\">concat方法,它是用于连接多个数组组成一个新的数组的方法。那么，我们只要连接它自己，即可完成数组的深拷贝。<br>var arr2 = arr.concat()</li><li style=\"text-align: start;\">ES6扩展运算符实现,该方法是最简单的（es6的展开语法只针对第一层，对多层还是浅拷贝方式）<br>var arr2 = [...arr]</li></ol><p style=\"text-align: start;\">对象或数组，使用递归函数实现深拷贝</p><p style=\"text-align: left;\"><br></p><pre><code >function deepCopy(obj) {\n  let newObj = Array.isArray(obj) ? [] : {};\n\n  for (let key in obj) {\n    if (typeof obj[key] === \"object\") {\n      newObj[key] = deepCopy(obj[key]);\n    } else {\n      newObj[key] = obj[key];\n    }\n  }\n\n  return newObj;\n}\nconst obj = { a: 1, b: { c: 2 } };\nconst obj2 = deepCopy(obj);</code></pre><hr/><h2><a href=\"#sjjcfa\" name=\"sjjcfa\">JS中的数据类型检测方案</a></h2><h3 style=\"text-align: start;\">1.typeof</h3><ul><li style=\"text-align: start;\">console.log(typeof 1); // number</li><li style=\"text-align: start;\">console.log(typeof true); // boolean</li><li style=\"text-align: start;\">console.log(typeof 'mc'); // string</li><li style=\"text-align: start;\">console.log(typeof Symbol()) // symbol</li><li style=\"text-align: start;\">console.log(typeof function(){}); // function</li><li style=\"text-align: start;\">console.log(typeof console.log()); // function</li><li style=\"text-align: start;\">console.log(typeof []); // object</li><li style=\"text-align: start;\">console.log(typeof {}); // object</li><li style=\"text-align: start;\">console.log(typeof null); // object</li><li style=\"text-align: start;\">console.log(typeof undefined); // undefined</li></ul><p style=\"text-align: start;\">优点：能够快速区分基本数据类型</p><p style=\"text-align: start;\">缺点：不能将Object、Array和Null区分，都返回object</p><h3 style=\"text-align: start;\">2.instanceof</h3><ol><li style=\"text-align: start;\">console.log(1 instanceof Number); // false</li><li style=\"text-align: start;\">console.log(true instanceof Boolean); // false</li><li style=\"text-align: start;\">console.log('str' instanceof String); // false</li><li style=\"text-align: start;\">console.log([] instanceof Array); // true</li><li style=\"text-align: start;\">console.log(function(){} instanceof Function); // true</li><li style=\"text-align: start;\">console.log({} instanceof Object); // true</li></ol><p style=\"text-align: start;\">优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象</p><p style=\"text-align: start;\">缺点：Number，Boolean，String基本数据类型不能判断</p><h3 style=\"text-align: start;\">3.Object.prototype.toString.call()<span style=\"color: rgb(33, 37, 41); background-color: rgb(255, 255, 255); font-size: 14px;\">var toString = Object.prototype.toString;</span></h3><ol><li style=\"text-align: start;\">console.log(toString.call(1)); //[object Number]</li><li style=\"text-align: start;\">console.log(toString.call(true)); //[object Boolean]</li><li style=\"text-align: start;\">console.log(toString.call('mc')); //[object String]</li><li style=\"text-align: start;\">console.log(toString.call([])); //[object Array]</li><li style=\"text-align: start;\">console.log(toString.call({})); //[object Object]</li><li style=\"text-align: start;\">console.log(toString.call(function(){})); //[object Function]</li><li style=\"text-align: start;\">console.log(toString.call(undefined)); //[object Undefined]</li><li style=\"text-align: start;\">console.log(toString.call(null)); //[object Null]</li></ol><p style=\"text-align: start;\">优点：精准判断数据类型</p><p style=\"text-align: start;\">缺点：写法繁琐不容易记，推荐进行封装后使用</p><h3 style=\"text-align: start;\">instanceof 的作用</h3><ol><li style=\"text-align: start;\">用于判断一个引用类型是否属于某构造函数；</li><li style=\"text-align: start;\">还可以在继承关系中用来判断一个实例是否属于它的父类型。</li></ol><h3 style=\"text-align: start;\">instanceof 和 typeof 的区别：</h3><ol><li style=\"text-align: start;\">typeof在对值类型number、string、boolean 、null 、 undefined、 以及引用类型的function的反应是精准的；</li><li style=\"text-align: start;\">但是，对于对象{ } 、数组[ ] 、null 都会返回object</li><li style=\"text-align: start;\">为了弥补这一点，instanceof 从原型的角度，来判断某引用属于哪个构造函数，从而判定它的数据类型。</li></ol><hr/><h2 style=\"text-align: start;\"><a href=\"#varletconst\" name=\"varletconst\">var &amp;&amp; let &amp;&amp; const的区别</a></h2><h3 style=\"text-align: start;\">ES6之前创建变量用的是var,之后创建变量用的是let/const</h3><p>三者区别</p><ul><li style=\"text-align: start;\">var定义的变量，`没有块的概念，可以跨块访问`, 不能跨函数访问。</li><li style=\"text-align: start;\">let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。</li><li style=\"text-align: start;\">const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，且不能修改。</li><li style=\"text-align: start;\">var可以`先使用，后声明`，因为存在变量提升；let必须先声明后使用。</li><li style=\"text-align: start;\">var是允许在相同作用域内`重复声明同一个变量`的，而let与const不允许这一现象。</li><li style=\"text-align: start;\">在全局上下文中，基于let声明的全局变量和全局对象GO（window）没有任何关系 ;</li><li style=\"text-align: start;\">var声明的变量会和GO有映射关系；会产生暂时性死区</li><li style=\"text-align: start;\"><span style=\"color: rgb(235, 144, 58);\">let /const/function会把当前所在的大括号(除函数之外)作为一个全新的块级上下文，应用这个机制，在开发项目的时候，遇到循环事件绑定等类似的需求，无需再自己构建闭包来存储，只要基于let的块作用特征即可解决</span></li></ul><hr/><h2 style=\"text-align: start;\"><a href=\"#zyyhzyyl\" name=\"zyyhzyyl\">作用域和作用域链</a></h2><h5 style=\"text-align: start;\">创建函数的时候，已经声明了当前函数的作用域==&gt;`当前创建函数所处的上下文`。如果是在全局下创建的函数就是`[[scope]]:EC(G)`，函数执行的时候，形成一个全新的私有上下文`EC(FN)`，供字符串代码执行(进栈执行)</h5><h5 style=\"text-align: start;\">定义：简单来说作用域就是变量与函数的可访问范围，`由当前环境与上层环境的一系列变量对象组成</h5><p>1.全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。</p><p>2.函数作用域：在固定的代码片段才能被访问</p><p style=\"text-align: start;\"><span style=\"color: rgb(235, 144, 58);\">作用：作用域最大的用处就是`隔离变量`，不同作用域下同名变量不会有冲突。</span></p><p style=\"text-align: start;\"><span style=\"color: rgb(235, 144, 58);\">一般情况下，变量到 创建该变量 的函数的作用域中取值。但是如果在当前作用域中没有查到，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。</span></p><hr/><h2 style=\"text-align: start;\"><a href=\"#bbhh\" name=\"bbhh\">闭包</a></h2><h3 style=\"text-align: start;\">闭包的两大作用：保存/保护</h3><h3 style=\"text-align: start;\">闭包的概念</h3><p style=\"text-align: start;\">函数执行时形成的私有上下文EC(FN)，正常情况下，代码执行完会出栈后释放;但是特殊情况下，如果当前私有上下文中的某个东西被上下文以外的事物占用了，则上下文不会出栈释放，从而形成不销毁的上下文。 函数执行函数执行过程中，会形成一个全新的私有上下文，可能会被释放，可能不会被释放，不论释放与否，他的作用是：</p><p style=\"text-align: start;\">（1）保护：划分一个独立的代码执行区域，在这个区域中有自己私有变量存储的空间，保护自己的私有变量不受外界干扰（操作自己的私有变量和外界没有关系）；</p><p style=\"text-align: start;\">（2）保存：如果当前上下文不被释放【只要上下文中的某个东西被外部占用即可】，则存储的这些私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来了；</p><p style=\"text-align: start;\">我们把函数执行形成私有上下文，来保护和保存私有变量机制称为闭包</p><p style=\"text-align: start;\">闭包是指有权访问另一个函数作用域中的变量的函数--《JavaScript高级程序设计》</p><h3 style=\"text-align: start;\">稍全面的回答</h3><p style=\"text-align: start;\">在js中变量的作用域属于函数作用域, 在函数执行完后,作用域就会被清理,内存也会随之被回收,但是由于闭包函数是建立在函数内部的子函数, 由于其可访问上级作用域,即使上级函数执行完, 作用域也不会随之销毁, 这时的子函数(也就是闭包),便拥有了访问上级作用域中变量的权限,即使上级函数执行完后作用域内的值也不会被销毁。</p><h3 style=\"text-align: start;\">闭包的特性</h3><ol><li style=\"text-align: start;\">内部函数可以访问定义他们外部函数的参数和变量。(作用域链的向上查找，把外围的作用域中的变量值存储在内存中而不是在函数调用完毕后销毁)设计私有的方法和变量，避免全局变量的污染。</li><li style=\"text-align: start;\">函数嵌套函数</li><li style=\"text-align: start;\">本质是将函数内部和外部连接起来。优点是可以读取函数内部的变量，让这些变量的值始终保存在内存中，不会在函数被调用之后自动清除</li></ol><h3 style=\"text-align: start;\">闭包形成的条件</h3><ol><li style=\"text-align: start;\">函数的嵌套</li><li style=\"text-align: start;\">内部函数引用外部函数的局部变量，延长外部函数的变量生命周期</li></ol><h3 style=\"text-align: start;\">闭包的用途</h3><ol><li style=\"text-align: start;\">模仿块级作用域</li><li style=\"text-align: start;\">保护外部函数的变量 能够访问函数定义时所在的词法作用域(阻止其被回收)</li><li style=\"text-align: start;\">封装私有化变量</li><li style=\"text-align: start;\">创建模块</li></ol><h3 style=\"text-align: start;\">闭包应用场景</h3><p>闭包的两个场景，闭包的两大作用：`保存/保护`。</p><p style=\"text-align: start;\">在开发中, 其实我们随处可见闭包的身影, 大部分前端JavaScript 代码都是“事件驱动”的,即一个事件绑定的回调方法; 发送ajax请求成功|失败的回调;setTimeout的延时回调;或者一个函数内部返回另一个匿名函数,这些都是闭包的应用。</p><p style=\"text-align: start;\"><span style=\"color: rgb(255, 77, 79);\">闭包的优点：延长局部变量的生命周期</span></p><p style=\"text-align: start;\"><span style=\"color: rgb(255, 77, 79);\">闭包的缺点：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</span></p><p style=\"text-align: start;\"><br></p><hr/><h2 style=\"text-align: start;\"><a href=\"#jsthis\" name=\"jsthis\">JS 中 this 的情况</a></h2><ol><li style=\"text-align: start;\">普通函数调用：通过函数名()直接调用：`this`指向`全局对象window`（注意let定义的变量不是window属性，只有window.xxx定义的才是。即let a =’aaa’; this.a是undefined）</li><li style=\"text-align: start;\">构造函数调用：函数作为构造函数，用new关键字调用时：`this`指向`新new出的对象`</li><li style=\"text-align: start;\">对象函数调用：通过对象.函数名()调用的：`this`指向`这个对象`</li><li style=\"text-align: start;\">箭头函数调用：箭头函数里面没有 this ，所以`永远是上层作用域this`（上下文）</li><li style=\"text-align: start;\">apply和call调用：函数体内 this 的指向的是 call/apply 方法`第一个参数`，若为空默认是指向全局对象window。</li><li style=\"text-align: start;\">函数作为数组的一个元素，通过数组下标调用的：this指向这个数组</li><li style=\"text-align: start;\">函数作为window内置函数的回调函数调用：this指向window（如setInterval setTimeout 等）</li></ol><hr/><h2><a href=\"#callapplbind\" name=\"callapplbind\">call/apply/bind 的区别</a></h2><h5 style=\"text-align: start;\">相同</h5><ol><li style=\"text-align: start;\">都是用来改变函数的this对象的指向的</li><li style=\"text-align: start;\">第一个参数都是this要指向的对象</li><li style=\"text-align: start;\">都可以利用后续参数传参</li></ol><h5 style=\"text-align: start;\">不同</h5><ol><li style=\"text-align: start;\">apply和call传入的参数列表形式不同,apply 接收 arguments，call接收一串参数列表</li><li style=\"text-align: start;\">bind：语法和call一模一样，区别在于立即执行还是等待执行，bind不兼容IE6~8</li><li style=\"text-align: start;\">bind 主要就是将函数绑定到某个对象，bind()会创建一个函数，返回对应函数便于稍后调用；而apply、call则是立即调用。</li></ol><p style=\"text-align: start;\"><span style=\"color: rgb(212, 56, 13);\">总结：基于Function.prototype上的 ` apply 、 call 和 bind `调用模式，这三个方法都可以显示的指定调用函数的 this 指向。`apply`接收参数的是数组，`call`接受参数列表，`` bind`方法通过传入一个对象，返回一个` this ` 绑定了传入对象的新函数。这个函数的 `this`指向除了使用`new `时会被改变，其他情况下都不会改变。若为空默认是指向全局对象window。</span></p><p style=\"text-align: start;\"><br></p><hr/><h2><a href=\"#jthsdtx\" name=\"jthsdtx\">箭头函数的特性</a></h2><ol><li style=\"text-align: start;\">`箭头函数没有自己的this`，会捕获其所在的上下文的this值，作为自己的this值</li><li style=\"text-align: start;\">`箭头函数没有constructor`，是匿名函数，不能作为构造函数，不能通过new 调用；</li><li style=\"text-align: start;\">`没有new.target 属性`。在通过new运算符被初始化的函数或构造方法中，new.target返回一个指向构造方法或函数的引用。在普通的函数调用中，new.target 的值是undefined</li><li style=\"text-align: start;\">`箭头函数不绑定Arguments 对象`。取而代之用rest参数...解决。由于 箭头函数没有自己的this指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定this），他们的第一个参数会被忽略。（这种现象对于bind方法同样成立）</li><li style=\"text-align: start;\">箭头函数通过 call() 或 apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。</li><li style=\"text-align: start;\">箭头函数没有原型属性 Fn.prototype 值为 undefined</li><li style=\"text-align: start;\">箭头函数不能当做Generator函数,不能使用yield关键字</li></ol><hr/><h2></h2><h2 style=\"text-align: start;\"><a href=\"#yxhyxl\" name=\"yxhyxl\">原型关系：原型 &amp;&amp; 原型链</a></h2><ol><li style=\"text-align: start;\">每个 class都有显示原型 prototype</li><li style=\"text-align: start;\">每个实例都有隐式原型 `__proto__`</li><li style=\"text-align: start;\">实例的 `__proto__` 指向对应 class 的 prototype</li><li style=\"text-align: start;\">原型</li></ol><p style=\"text-align: start;\">在 JS 中，每当定义一个对象（函数也是对象）时，对象中都会包含一些预定义的属性。其中每个`函数对象`都有一个`prototype` 属性，这个属性指向函数的`原型对象`。</p><p style=\"text-align: start;\">原型链</p><p style=\"text-align: start;\">函数的原型链对象constructor默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针__proto__,该指针是指向上一层的原型对象，而上一层的原型对象的结构依然类似。因此可以利用__proto__一直指向Object的原型对象上，而Object原型对象用Object.prototype.__ proto__ = null表示原型链顶端。如此形成了js的原型链继承。同时所有的js对象都有Object的基本防范</p><p style=\"text-align: start;\">特点</p><p style=\"text-align: start;\"><span style=\"color: rgb(255, 122, 69);\">`JavaScript`对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</span></p><hr/><h2><a href=\"#nvew\" name=\"nvew\">new运算符的实现机制</a></h2><ol><li style=\"text-align: start;\">首先创建了一个新的`空对象`</li><li style=\"text-align: start;\">`设置原型`，将对象的原型设置为函数的`prototype`对象。</li><li style=\"text-align: start;\">让函数的`this`指向这个对象，执行构造函数的代码（为这个新对象添加属性）</li><li style=\"text-align: start;\">判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li></ol><hr/><h2><a href=\"#eventloop\" name=\"eventloop\">EventLoop 事件循环</a></h2><p style=\"text-align: start;\">是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列。微任务队列的代表就是，</p><p style=\"text-align: start;\">`JS``Promise.then`，`MutationObserver`，宏任务的话就是`setImmediate setTimeout setInterval`</p><p style=\"text-align: start;\">JS运行的环境。一般为浏览器或者Node。 在浏览器环境中，有JS 引擎线程和渲染线程，且两个线程互斥。 Node环境中，只有JS 线程。 不同环境执行机制有差异，不同任务进入不同Event Queue队列。 当主程结束，先执行准备好微任务，然后再执行准备好的宏任务，一个轮询结束。</p><hr/><h2><a href=\"#eventlooplbrow\" name=\"eventlooplbrow\">浏览器中的事件循环（Event Loop)</a></h2><h5 style=\"text-align: start;\">事件循环的运行机制</h5><p style=\"text-align: start;\">先会执行栈中的内容，栈中的内容执行后执行微任务，微任务清空后再执行宏任务，先取出一个宏任务，再去执行微任务，然后在取宏任务清微任务这样不停的循环。</p><h5 style=\"text-align: start;\">eventLoop 是由JS的宿主环境（浏览器）来实现的；</h5><p>事件循环可以简单的描述为以下四个步骤:</p><ol><li style=\"text-align: start;\">函数入栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空；</li><li style=\"text-align: start;\">此期间WebAPIs完成这个事件，把回调函数放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列）</li><li style=\"text-align: start;\">执行栈为空时，Event Loop把微任务队列执行清空；</li><li style=\"text-align: start;\">微任务队列清空后，进入宏任务队列，取队列的第一项任务放入Stack(栈）中执行，执行完成后，查看微任务队列是否有任务，有的话，清空微任务队列。重复4，继续从宏任务中取任务执行，执行完成之后，继续清空微任务，如此反复循环，直至清空所有的任务。</li></ol><h5 style=\"text-align: start;\">浏览器中的任务源(task)</h5><p>宏任务(macrotask)</p><p style=\"text-align: start;\">宿主环境提供的，比如浏览器</p><p style=\"text-align: start;\">ajax、setTimeout、setInterval、setTmmediate(只兼容ie)、script、requestAnimationFrame、messageChannel、UI渲染、一些浏览器api</p><p style=\"text-align: start;\">微任务(microtask)</p><p style=\"text-align: start;\">语言本身提供的，比如promise.then</p><p style=\"text-align: start;\">queueMicrotask(基于then)、mutationObserver(浏览器提供)、messageChannel 、mutationObersve</p><hr/><h2><a href=\"#settimoutpromise\" name=\"settimoutpromise\">setTimeout、Promise、Async/Await 的区别</a></h2><h3 style=\"text-align: start;\">setTimeout</h3><p style=\"text-align: start;\">settimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行。</p><h3 style=\"text-align: start;\">Promise</h3><p style=\"text-align: left;\">Promise本身是**同步的立即执行函数**， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行。</p><p style=\"text-align: left;\">```js<br>console.log('script start')<br>let promise1 = new Promise(function (resolve) {<br>console.log('promise1')<br>resolve()<br>console.log('promise1 end')<br>}).then(function () {<br>console.log('promise2')<br>})<br>setTimeout(function(){<br>console.log('settimeout')<br>})<br>console.log('script end')<br>// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</p><h3 style=\"text-align: start;\">async/await</h3><p style=\"text-align: left;\">async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p><p style=\"text-align: left;\">```js<br>async function async1(){<br>console.log('async1 start');<br>await async2();<br>console.log('async1 end')<br>}<br>async function async2(){<br>console.log('async2')<br>}<br><br>console.log('script start');<br>async1();<br>console.log('script end')<br><br>// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</p><hr/><p><br></p>","hrefList":[{"name":"jsbzsjlx","title":"JS中的8种数据类型及区别"},{"name":"sjjcfa","title":"JS中的数据类型检测方案"},{"name":"varletconst","title":"var &amp;&amp; let &amp;&amp; const的区别"},{"name":"zyyhzyyl","title":"作用域和作用域链"},{"name":"bbhh","title":"闭包"},{"name":"jsthis","title":"JS 中 this 的情况"},{"name":"callapplbind","title":"call/apply/bind 的区别"},{"name":"jthsdtx","title":"箭头函数的特性"},{"name":"yxhyxl","title":"原型关系：原型 &amp;&amp; 原型链"},{"name":"nvew","title":"new运算符的实现机制"},{"name":"eventloop","title":"EventLoop 事件循环"},{"name":"eventlooplbrow","title":"浏览器中的事件循环（Event Loop)"},{"name":"settimoutpromise","title":"setTimeout、Promise、Async/Await 的区别"}],"id":1713075970211,"lookNum":9547},{"title":"React","subTitle":"React是Facebook的一个开源JS框架，专注的层面为View层","label":[],"time":"2024-05-04 15:17:09","uptime":"2024-05-04 15:42:33","creator":"风中追风","type":"tech","abstract":"React认为一切页面元素都可以抽象成组件","logo":"https://img1.baidu.com/it/u=2079992994,1830113805&fm=253&fmt=auto&app=138&f=PNG?w=500&h=500","content":"<h2><a href=\"#introduce\" name=\"introduce\">React介绍</a></h2><p><span style=\"color: rgb(33, 37, 41); background-color: rgb(255, 255, 255); font-size: 16px;\">React就是Facebook的一个开源JS框架，专注的层面为View层，不包括数据访问层或者那种Hash路由（不过React 有插件支持），与Angularjs，Emberjs等大而全的框架不同，React专注的中心是Component，即组件。React认为一切页面元 素都可以抽象成组件，比如一个表单，或者表单中的某一项。</span></p><p style=\"text-align: start;\">React可以作为MVVM中第二个V，也就是View，但是并不是MVVM框架。MVVM一个最显著的特征：双向绑定。React没有这个，它是单向数据绑定的。React是一个单向数据流的库，状态驱动视图。react整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流，推崇结合immutable来实现数据不可变。</p><hr/><h2 style=\"text-align: start;\"><a href=\"#hooksyqd\" name=\"hooksyqd\">Hooks的优缺点</a></h2><h3 style=\"text-align: start;\">优点</h3><ol><li style=\"text-align: start;\">代码的可读性强，在使用hooks之前比如发布/订阅自定义事件被挂载在componentDidMount生命周期中，然后需要在componentWillUnmount生命周期中将它清楚，这样就不便于开发者维护和迭代。在使用hooks之后，通过useEffect可以将componentDidMount生命周期、componentDidUpdate生命周期和componentWillUnmount生命周期聚合起来，方便代码的维护。</li><li style=\"text-align: start;\">组件层级变得更浅了，在使用hooks之前通常使用高阶组件HOC的方法来复用多个组件公共的状态，增强组建的功能，这样肯定是加大了组件渲染的开销，损失了性能。但是在hooks中可以通过自定义组件useXxx()的方法将多个组件之间的共享逻辑放在自定义hook中，就可以轻松的进行数据互通。</li><li style=\"text-align: start;\">不再需要考虑class组件中this指向的问题，hook在函数组件中不需要通过this.state或者this.fn来获取数据或者方法。</li></ol><h3 style=\"text-align: start;\">缺点</h3><ol><li style=\"text-align: start;\">hooks的useEffect只包括了componentDidMount、componentDidUpdate还有componentWillUnmount这三个生命周期，对于getSnapshotBeforeUpdate和componentDidCatch等其他的生命周期没有支持。</li><li style=\"text-align: start;\">使用useEffect时候里面不能写太多依赖项，将各个不同的功能划分为多个useEffect模块，将各项功能拆开写，这是遵循了软件设计的“单一职责模式”。如果遇到状态不同步的情况，使用手动传递参数的形式。</li><li style=\"text-align: start;\">如果业务复杂，就使用Component代替hooks，hooks的出现并不是取代了class组件，而是在函数组件的基础上可以实现一部分的类似class组件功能。</li></ol><hr/><h2 style=\"text-align: start;\"><a href=\"#classyuhssqb\" name=\"classyuhssqb\">Class组件与函数式组件的区别</a></h2><p style=\"text-align: start;\">类组件是使用ES6 的 class 来定义的组件。 函数组件是接收一个单一的 `props` 对象并返回一个React元素。</p><p style=\"text-align: start;\">关于React的两套API（类（class）API 和基于函数的钩子（hooks） API）。官方推荐使用钩子（函数），而不是类。因为钩子更简洁，代码量少，用起来比较\"轻\"，而类比较\"重\"。而且，钩子是函数，更符合 React 函数式的本质。</p><p style=\"text-align: start;\">函数一般来说，只应该做一件事，就是返回一个值。 如果你有多个操作，每个操作应该写成一个单独的函数。而且，数据的状态应该与操作方法分离。根据函数这种理念，React 的函数组件只应该做一件事情：返回组件的 HTML 代码，而没有其他的功能。函数的返回结果只依赖于它的参数。不改变函数体外部数据、函数执行过程里面没有副作用。</p><h3 style=\"text-align: start;\">类（class）是数据和逻辑的封装。</h3><p style=\"text-align: start;\">也就是说，组件的状态和操作方法是封装在一起的。如果选择了类的写法，就应该把相关的数据和操作，都写在同一个class 里面。</p><h4 style=\"text-align: start;\">类组件的缺点</h4><ol><li style=\"text-align: start;\">大型组件很难拆分和重构，也很难测试。</li><li style=\"text-align: start;\">业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。</li><li style=\"text-align: start;\">组件类引入了复杂的编程模式，比如 render props 和高阶组件。</li><li style=\"text-align: start;\">难以理解的 class，理解 JavaScript 中 `this` 的工作方式。</li></ol><h4 style=\"text-align: start;\">区别</h4><p>函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。</p><ol><li style=\"text-align: start;\">状态的有无</li><li style=\"text-align: start;\">调用方式的不同</li><li style=\"text-align: start;\">因为调用方式不同，在函数组件使用中会出现问题</li></ol><hr/><h2 style=\"text-align: start;\"><a href=\"#gzhs\" name=\"gzhs\">React Hooks钩子函数</a></h2><h3 style=\"text-align: start;\">*Hook* 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</h3><ul><li style=\"text-align: start;\">`useState()` //状态钩子</li><li style=\"text-align: start;\">`useContext()` //共享状态钩子</li><li style=\"text-align: start;\">`useReducer()` //action 钩子</li><li style=\"text-align: start;\">`useEffect()` //副作用钩子</li><li style=\"text-align: start;\">useCallback 记忆函数</li><li style=\"text-align: start;\">useMemo 记忆组件</li><li style=\"text-align: start;\">useRef 保存引用值</li><li style=\"text-align: start;\">useImperativeHandle 穿透 Ref</li><li style=\"text-align: start;\">useLayoutEffect 同步执行副作用</li><li style=\"text-align: start;\">useEffect和useLayoutEffect有什么区别</li></ul><p style=\"text-align: start;\">简单来说就是调用时机不同，useLayoutEffect和原来componentDidMount&amp;componentDidUpdate一致，在react完成DOM更新后马上同步调用的代码，会阻塞页面渲染。而useEffect是会在整个页面渲染完才会调用的代码。`官方建议优先使用useEffect</p><p style=\"text-align: start;\"><br></p><hr/><h2><a href=\"#redux\" name=\"redux\">Redux介绍</a></h2><h3 style=\"text-align: start;\">什么是Redux</h3><p style=\"text-align: start;\">redux是专门用于集中式管理状态的javascript库</p><h3 style=\"text-align: start;\">Redux工作流程</h3><p>分别为actions、store、reducers（带s的表明可能存在多个）</p><ol><li style=\"text-align: start;\">让Action Creators创建action</li><li style=\"text-align: start;\">通过dispatch将action分发出去</li><li style=\"text-align: start;\">store对要使用的reducer进行绑定，然后将action分发到对应的reducer上</li><li style=\"text-align: start;\">在reducer上进行相应的action操作并返回结果给store</li><li style=\"text-align: start;\">组件就可以通过store的API像store进行获取操作返回的结果</li></ol><hr/><h2><a href=\"#txfs\" name=\"txfs\">React组件的通信方式</a></h2><h3 style=\"text-align: start;\">react组件间通信常见的几种情况</h3><ol><li style=\"text-align: start;\">父组件向子组件通信</li><li style=\"text-align: start;\">子组件向父组件通信</li><li style=\"text-align: start;\">跨级组件通信```js<br>// context方式实现跨级组件通信<br>// Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据<br><br>const BatteryContext = createContext();<br><br>// 子组件的子组件</li></ol><pre><code >\nclass GrandChild extends Component {\n  render(){\n    return (\n      &lt;BatteryContext.Consumer&gt;\n    {\n        color =&gt; &lt;h1 style={{\"color\":color}}&gt;我是红色的:{color}&lt;/h1&gt;\n    }\n&lt;/BatteryContext.Consumer&gt;\n    )\n  }\n}\n\n// 子组件\nconst Child = () =&gt;{\n  return (\n    &lt;GrandChild /&gt;\n  )\n}\n// 父组件</code></pre><pre><code >\nclass Parent extends Component {\n  state = {\n    color:\"red\"\n  }\n  render(){\n    const {color} = this.state\n      return (\n        &lt;BatteryContext.Provider value={color}&gt;\n          &lt;Child&gt;&lt;/Child&gt;\n      &lt;/BatteryContext.Provider &gt;\n     )\n  }\n}\n```</code></pre><h4 style=\"text-align: start;\">4.非嵌套关系的组件通信</h4><p style=\"text-align: left;\">即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。</p><ol><li style=\"text-align: left;\">可以使用自定义事件通信（发布订阅模式），使用pubsub-js</li><li style=\"text-align: left;\">可以通过redux等进行全局状态管理</li><li style=\"text-align: left;\">如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。</li><li style=\"text-align: left;\">也可以new一个 NODE 的 EventBus,进行事件监听，一边执行监听，一边执行新增 NODE的eventBus 就是发布订阅模式，是可以在React中使用的;</li></ol><p style=\"text-align: left;\"><br></p><hr/><h2><a href=\"#setstatea\" name=\"setstatea\">setState既存在异步情况也存在同步情况</a></h2><h5 style=\"text-align: start;\">1.异步情况 在`React事件当中是异步操作`</h5><h5 style=\"text-align: start;\">2.同步情况 如果是在`setTimeout事件或者自定义的dom事件`中，都是同步的</h5><pre><code >```js\n//setTimeout事件\nimport React,{ Component } from \"react\";\nclass Count extends Component{\n  constructor(props){\n    super(props);\n    this.state = {\n      count:0\n    }\n  }\n  render(){\n    return (\n      &lt;&gt;\n          &lt;p&gt;count:{this.state.count}&lt;/p&gt;\n          &lt;button onClick={this.btnAction}&gt;增加&lt;/button&gt;\n      &lt;/&gt;\n    )\n  }\n  btnAction = ()=&gt;{\n  //不能直接修改state，需要通过setState进行修改\n  //同步\n    setTimeout(()=&gt;{\n      this.setState({\n        count: this.state.count + 1\n      });\n      console.log(this.state.count);\n    })\n  }\n}\n\nexport default Count;\n```\n```js\n//自定义dom事件\nimport React,{ Component } from \"react\";\nclass Count extends Component{\n  constructor(props){\n    super(props);\n    this.state = {\n      count:0\n    }\n  }\n\n  render(){\n    return (\n    &lt;&gt;\n        &lt;p&gt;count:{this.state.count}&lt;/p&gt;\n        &lt;button id=\"btn\"&gt;绑定点击事件&lt;/button&gt;\n    &lt;/&gt;\n    )\n    }\n\n  componentDidMount(){\n//自定义dom事件，也是同步修改\n    document.querySelector('#btn').addEventListener('click',()=&gt;{\n      this.setState({\n        count: this.state.count + 1\n        });\n      console.log(this.state.count);\n    });\n  }\n}\n\nexport default Count;</code></pre><p><br></p><hr/><h2><a href=\"#fiber\" name=\"fiber\">React-Fiber</a></h2><h3 style=\"text-align: start;\">1）背景</h3><p>react-fiber 产生的根本原因，是`大量的同步计算任务阻塞了浏览器的 UI 渲染`。默认情况下，JS 运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。如果 JS 运算持续占用主线程，页面就没法得到及时的更新。当我们调用`setState`更新页面的时候，React 会遍历应用的所有节点，计算出差异，然后再更新 UI。如果页面元素很多，整个过程占用的时机就可能超过 16 毫秒，就容易出现掉帧的现象。</p><h3 style=\"text-align: start;\">2）实现原理</h3><p>react内部运转分三层：</p><ol><li style=\"text-align: start;\">Virtual DOM 层，描述页面长什么样。</li><li style=\"text-align: start;\">Reconciler 层，负责调用组件生命周期方法，进行 Diff 运算等。</li><li style=\"text-align: start;\">Renderer 层，根据不同的平台，渲染出相应的页面，比较常见的是 ReactDOM 和 ReactNative。</li></ol><p style=\"text-align: start;\">Fiber 其实指的是一种数据结构，它可以用一个纯 JS 对象来表示</p><p style=\"text-align: start;\">```js<br>const fiber = {<br> &nbsp;stateNode, // 节点实例<br> &nbsp;child, // 子节点<br> &nbsp;sibling, // 兄弟节点<br> &nbsp;return, // 父节点<br>}<br>```<br></p><p style=\"text-align: start;\">为了实现不卡顿，就需要有一个调度器 (Scheduler) 来进行任务分配。优先级高的任务（如键盘输入）可以打断优先级低的任务（如Diff）的执行，从而更快的生效。任务的优先级有六种：</p><ol><li style=\"text-align: start;\">synchronous，与之前的Stack Reconciler操作一样，同步执行</li><li style=\"text-align: start;\">task，在next tick之前执行</li><li style=\"text-align: start;\">animation，下一帧之前执行</li><li style=\"text-align: start;\">high，在不久的将来立即执行</li><li style=\"text-align: start;\">low，稍微延迟执行也没关系</li><li style=\"text-align: start;\">offscreen，下一次render时或scroll时才执行</li><li style=\"text-align: start;\">Fiber Reconciler（react ）执行过程分为2个阶段：</li></ol><p style=\"text-align: start;\">生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。阶段一可被打断的特性，让优先级更高的任务先执行，从框架层面大大降低了页面掉帧的概率。</p><p style=\"text-align: start;\">将需要更新的节点一次过批量更新，这个过程不能被打断。</p><p style=\"text-align: start;\">Fiber树：React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为 Virtual DOM Tree，由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node，将 Fiber Node 链接起来的结构成为 Fiber Tree。Fiber Tree 一个重要的特点是链表结构，将递归遍历编程循环遍历，然后配合 requestIdleCallback API, 实现任务拆分、中断与恢复。</p><p style=\"text-align: start;\">从Stack Reconciler到Fiber Reconciler，源码层面其实就是干了一件递归改循环的事情</p><hr/><h2><a href=\"#portals\" name=\"portals\">Portals</a></h2><h5 style=\"text-align: start;\">Portals 提供了一种一流的方式来将子组件渲染到存在于父组件的 DOM 层次结构之外的 DOM 节点中。结构不受外界的控制的情况下就可以使用portals进行创建<br></h5><hr/><h2><a href=\"#ybzjzmsy\" name=\"ybzjzmsy\">何时要使用异步组件？怎么使用？</a></h2><ol><li style=\"text-align: start;\">加载大组件的时候</li><li style=\"text-align: start;\">路由异步加载的时候</li></ol><h3 style=\"text-align: start;\">react 中要配合 Suspense 使用</h3><p style=\"text-align: start;\">```js<br>// 异步懒加载<br>const Box = lazy(()=&gt;import('./components/Box'));<br> &nbsp;// 使用组件的时候要用suspense进行包裹<br> &nbsp;&lt;Suspense fallback={&lt;div&gt;loading...<br> &nbsp; &nbsp;&lt;/div&gt;}&gt;<br> &nbsp;&lt;/Suspense&gt;<br>```</p><hr/><h2><a href=\"#reactbdyl\" name=\"reactbdyl\">React事件绑定原理</a></h2><h2><span style=\"color: rgb(33, 37, 41); background-color: rgb(255, 255, 255); font-size: 14px;\">React并不是将click事件绑在该div的真实DOM上，而是`在document处监听所有支持的事件`，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。</span></h2><hr/><h2><a href=\"#reactlazy\" name=\"reactlazy\">React.lazy()实现的原理</a></h2><h3 style=\"text-align: start;\">React的懒加载示例：</h3><pre><code >``js\nimport React, { Suspense } from 'react';\n\nconst OtherComponent = React.lazy(() =&gt; import('./OtherComponent'));\n\nfunction MyComponent() {\n  return (\n    &lt;div&gt;\n      &lt;Suspense fallback={&lt;div&gt;Loading...\n        &lt;/div&gt;}&gt;\n        &lt;OtherComponent /&gt;\n      &lt;/Suspense&gt;\n    &lt;/div&gt;\n    );\n}\n```</code></pre><p style=\"text-align: start;\">至此，我们分析完了 React 的懒加载原理。简单来说，React利用 React.lazy与import()实现了渲染时的动态加载 ，并利用Suspense来处理异步加载资源时页面应该如何显示的问题。</p><p><br></p>","hrefList":[{"name":"introduce","title":"React介绍"},{"name":"hooksyqd","title":"Hooks的优缺点"},{"name":"classyuhssqb","title":"Class组件与函数式组件的区别"},{"name":"gzhs","title":"React Hooks钩子函数"},{"name":"redux","title":"Redux介绍"},{"name":"txfs","title":"React组件的通信方式"},{"name":"setstatea","title":"setState既存在异步情况也存在同步情况"},{"name":"fiber","title":"React-Fiber"},{"name":"portals","title":"Portals"},{"name":"ybzjzmsy","title":"何时要使用异步组件？怎么使用？"},{"name":"reactbdyl","title":"React事件绑定原理"},{"name":"reactlazy","title":"React.lazy()实现的原理"}],"id":1714807029135,"lookNum":2254}]